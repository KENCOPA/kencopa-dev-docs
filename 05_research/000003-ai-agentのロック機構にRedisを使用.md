---
type: note
moc: "[[🏷️ADR]]"
tags:
- ElasticCache
- Redis
- ai/ref
---
> [!info] 必要なセクションを選択して使用してください！

# 📜 文脈・背景

- AIエージェントとのチャットシステムにおいて、各セッションごとに最新 N 件の会話履歴を高速かつ安全に扱う必要がある。
    
- 同一セッションに対して同時に複数の Lambda 関数が処理を行うと、会話履歴の整合性が失われるリスクがある。
    
- 会話履歴はキャッシュ的に運用しつつも、TTL による自動消失は避け、必要に応じて永続化ストレージと連携する設計とする。
    
- ミリ秒単位の高速アクセスと実装のシンプルさを重視し、追加サービスを最小限に抑えたロック機構を検討する。
    

# 🎨 対応案

以下のロック方式を検討した：

1. **Redis の SET NX + Lua スクリプトによるシンプルロック**
    
    - `SET key value NX PX <timeout>` でロックを取得し、Lua スクリプトで所有者チェックのうえ解放する。
        
    - 既存の ElastiCache for Redis クラスターをそのまま利用可能。
        
2. **Redlock アルゴリズムによる分散ロック**
    
    - 複数 AZ にまたがる独立した Redis プライマリを用意し、Redlock ライブラリでロック制御。
        
    - 単一ノード障害耐性を高められるが、クラスタ構成と運用が複雑化する。
        
3. **SQS FIFO の MessageGroupId による順次・排他処理**
    
    - SQS FIFO キューに Chat リクエストを投入し、`MessageGroupId = session_id` で順序保証。
        
    - AWS フルマネージドだが、レイテンシが増大しアーキテクチャ変更コストが高い。
        
4. **DynamoDB 条件付き書き込みによるロックテーブル**
    
    - DynamoDB テーブルにロック状態をマッピングし、条件付き `PutItem`／`DeleteItem` で制御。
        
    - レイテンシがやや高くなるが、永続性とバックアップが自動化可能。
        

# 🚀 決定

シンプルさと既存リソースの活用を最優先し、Redis の `SET NX` + Lua スクリプトによるシンプルロック方式を採用する。  
具体的には、以下の運用手順で実装を行う：

1. セッション単位で `lock:session:<session_id>` キーを生成し、`SET lock_key lock_value NX PX 30000` でロックを取得する。
    
2. 処理完了時は Lua スクリプトを用いて、キーの値が `lock_value` と一致する場合のみ `DEL` を実行し解放する。
    
3. 異常終了時やタイムアウト時には Redis が自動的にキーを削除し、デッドロックを防止する。
    

# 🪞 結果・影響

## プラスの結果

- **高速性**：Redis によるミリ秒単位のロック取得／解放で、セッション整合性を保ちながら高速処理が可能。
    
- **シンプル実装**：既存の ElastiCache for Redis をそのまま利用し、外部依存サービスを増やさずに完結。
    
- **自動解放**：TTL による自動開放機能で、Lambda 異常終了時のデッドロックを防止。
    

## マイナスの結果

- **単一ノード障害**：Redis クラスターのプライマリがダウンするとロック取得不可となるリスクがある。
    
- **TTL調整負荷**：処理内容に応じた適切なロック TTL 設定が必要で、短すぎると解放前にタイムアウト、長すぎると次処理が待機。
    
- **永続化要件未対応**：フル履歴分析は別途 DynamoDB 等への永続化フローを実装する必要がある。
    

# 🍜 今後の検討事項

- Redis クラスターの可用性向上策として、プライマリ冗長化やフェイルオーバー設定の最適化を検討する。
    
- ロック TTL の運用モニタリングを実施し、最適値の調整と警告設定を行う。
    
- 会話履歴の長期保存要件が発生した際に、ElastiCache から DynamoDB へのバッチ移行フローを設計する。
    
- Redis の AOF 永続化オプション利用や RDB スナップショット運用を検討し、メモリ内データの保全性を強化する。

