---
type: note
moc: "[[🏷️ADR]]"
tags:
- ElasticCache
- Dynamo
- MemoryDB
- Redis
- ai/ref
---
> [!info] 必要なセクションを選択して使用してください！

# 📜 文脈・背景

- AI エージェントとのチャットシステムにおいて、各セッションの「最新 N 話分の会話履歴」を高速に保持しつつ、他の Lambda から同一セッションをロック／解放する必要がある。
- 会話履歴はキャッシュ的に扱いたいが、セッションが途切れて時間を空けて再開される可能性もあるため、TTL で勝手に消えてしまうのは避けたい。
- 永続化よりも「ミリ秒単位の高速アクセス」と「シンプルなスライディングウィンドウ保持」が重視される。
- フルマネージドでフェイルオーバー／バックアップを自動化したい一方、コストや運用の複雑さは適度に抑えたい。

# 🎨 対応案

## 案1. DynamoDB だけで管理
    
- 会話履歴テーブルに最新 N 件だけ保持するロジックを組み込む（ConditionExpression とトランザクション利用）     
- **メリット**：追加サービス不要、永続性確保
- **デメリット**：レイテンシが Redis 比で高い、実装がやや煩雑
        
## 案2. ElastiCache for Redis
    
- LPUSH＋LTRIM で常に最新 N 件をリストに保持し、キーに TTL を設定しない     
- フルマネージドのレプリケーション／スナップショット機能で可用性を担保
- **メリット**：ミリ秒レベルの応答、運用管理コスト低減
- **デメリット**：メモリ課金、Redis 固有の運用知見が必要
    
## 案3.  **Amazon MemoryDB for Redis**
    
- ElastiCache 同様の操作性に加え、RDB/AOF 永続化が標準／SLA 99.99%     
- **メリット**：障害時のデータロストをほぼ完全排除
- **デメリット**：ElastiCache よりもコスト高、オーバースペックになり得る

# 🚀 決定

ElastiCache for Redis を採用し、セッションごとの最新 N 件会話履歴キャッシュを管理する。

以下の運用ルールを守る：

1. リスト操作は MULTI/EXEC でまとめて `LPUSH session:<ID> → LTRIM session:<ID> 0 N-1` を実行
2. キーには TTL を設定せず、ElastiCache のスナップショット／レプリケーショングループで永続化とフェイルオーバーを担保
3. 分散ロックが必要な場合は同クラスタ上で Redlock アルゴリズムを利用

# 🪞 結果・影響

- **プラスの結果**    
    - 会話履歴へのアクセスレイテンシが大幅に低減（ミリ秒単位）
    - マネージド定常運用によりフェイルオーバーやバックアップ設定が簡易化
    - 実装も Redis 標準コマンドのみで完結し、コードがシンプルに
        
    
- **マイナスの結果**
    - メモリ単価によるランニングコスト増加
    - Redis 自体の運用（パラメータグループ、クラスターモード設定）が新たに必要
    - フル履歴分析用には別途 DynamoDB など永続ストレージを組み合わせる必要あり

# 🍜 今後の検討事項

- 実運用開始後のキャッシュヒット率・メモリ使用量のモニタリング設定
- 会話履歴を長期保存したい場合の DynamoDB 連携フロー設計
- AOF 永続化オプションの活用可否（ElastiCache Redis 7.0+）
- セキュリティポリシー（VPC エンドポイント、サブネット構成）の最適化


