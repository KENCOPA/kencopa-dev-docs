---
type: note
moc: "[[🏷️research]]"
---
Author: atsushi.nakayama@kencopa.com
# Abstract

本ドキュメントは、バックエンドアプリケーションにおけるテスト戦略の曖昧さを解決するため、ユニットテストと統合テストの境界線を理論的・実践的に明確化するためのリサーチ結果である。

- **目的**
    - ユニットテストと統合テストの境界を明確に定義する
    - 各アプリケーション層（Presentation、Application、Domain、Infrastructure）における適切なテスト方針を確立する
    - 依存関係の分類に基づいた実践的なテスト戦略を提案する

- **主要な仮説**
    - 仮説1: ユニットテストと統合テストの境界は、依存関係の種類と扱い方によって明確に定義できる
    - 仮説2: 依存関係を体系的に分類することで、テスト手法の選択指針を提案できる
    - 仮説3: モジュールレベルのテストの位置づけは、依存関係の特性によって動的に決まる

- **リサーチ結果**
    - 依存関係を共有依存、プライベート依存、プロセス外依存の3つに分類し、各組み合わせに応じた判断基準を整理
    - アーキテクチャ層ごとの特性を踏まえたテスト戦略の指針案を策定
    - モジュールテストの分類は、分離性、依存関係の扱い、テスト範囲、実行環境の4要因で決定される可能性を示唆
	
このリサーチで整理した体系的なアプローチは、理論に基づきながらも実用的なテスト戦略の叩き台として活用できると考えている。今後、チームでの議論を経て、実際の開発方針として採用・調整していくことを想定している。

# 問題意識と仮説の出発点

## 個人的な問題意識
最近のプロジェクトで、以下のようなテスト戦略の課題を感じていた：

- ユニットテストと統合テストの境界が曖昧で、どこまでをユニットテストとして扱うべきか迷うことが多い
- 依存関係がある場合、モックを使うべきか実体を使うべきかの判断基準が不明確である
- モジュールレベルのテストが、ユニットテストなのか統合テストなのか位置づけに悩む

## 立てた仮説
これらの課題を解決するため、以下の仮説を立てた：

**仮説1**: ユニットテストと統合テストの境界は、依存関係の種類と扱い方によって明確に定義できる

**仮説2**: 依存関係を体系的に分類することで、テスト手法の選択指針を確立できる

**仮説3**: モジュールレベルのテストの位置づけは、依存関係の特性によって動的に決まる

## リサーチのアプローチ
これらの仮説を検証するため、以下のアプローチで個人リサーチを実施した：
- AIや既存の書籍やドキュメントからの情報収集
- 実際のコード例を用いた具体的な分析
- 依存関係の分類と特性の整理
- 仮説の妥当性の検証

# リサーチプロセスと発見の記録

## 第1段階：基本概念の再整理
まず、ユニットテストと統合テストの基本的な定義を複数の資料から調べ直した。
### ユニットテストと結合テストの特徴と違い

by claude
**ユニットテスト**:
1. 定義: プログラムの==最小単位(関数、メソッド、クラスなど)を個別にテスト==する手法です。
2. 目的: 個々のコンポーネントが期待通りに動作することを確認します。
3. 特徴:
    - 迅速で実行が容易
    - バグの早期発見に役立つ
    - コードの品質向上とリファクタリングの支援
4. 実施タイミング: 開発中、頻繁に実行されます。

**統合テスト**:
1. 定義: ==複数のコンポーネントやモジュールを組み合わせてテスト==する手法です。
2. 目的: コンポーネント間の相互作用や統合された機能が正しく動作することを確認します。
3. 特徴:
    - より複雑で、時間がかかる場合がある
    - システム全体の動作を確認できる
    - インターフェースや依存関係の問題を発見できる
4. 実施タイミング: 個々のコンポーネントの開発後、または定期的に実行されます。

主な違い:
1. スコープ: ==ユニットテストは個々の部品==、==統合テストはそれらの組み合わせ==をテストします。
2. 複雑さ: ユニットテストはシンプル、統合テストはより複雑です。
3. 実行速度: ユニットテストは高速、統合テストはより時間がかかります。
4. 発見できる問題: ユニットテストは個々の機能の問題、統合テストはコンポーネント間の問題を発見します。

### **ユニットテスト**における、**個々の部品**とは何なのか?
==「個々の部品」という表現が曖昧==で、メソッド/関数なのか、クラスなのか、モジュールなのか、実際のコードレベルでの具体性に欠けていた。この曖昧さが、ユニットテストと統合テストの境界を不明確にしている要因の一つであるのではないか？
(クラスも、メソッドの寄せ集めであり、他モジュールを使用している)

## 「個々の部品のテスト」の具体化

### 調査
ユニットテストにおける「個々の部品」は、ソースコードの様々なレベルの要素を指す可能性ある。  
主に以下のものが対象となる：

- メソッド/関数
- クラス
- モジュール

これらの中で、最も一般的なのはメソッド/関数レベルのテストである。ただし、具体的にどのレベルをユニットテストの対象とするかは、プログラミング言語、アーキテクチャ、チームの方針などによって異なることがある。

1. **メソッド/関数レベル**：
```python
def reverse_string(s):
    return s[::-1]

# テスト
def test_reverse_string():
    assert reverse_string("hello") == "olleh"
    assert reverse_string("") == ""
```

2. **クラスレベル**：
```python
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
    
    def deposit(self, amount):
        self.balance += amount
    
    def withdraw(self, amount):
        if amount > self.balance:
            raise ValueError("残高不足")
        self.balance -= amount

# テスト
def test_bank_account():
    account = BankAccount(100)
    account.deposit(50)
    assert account.balance == 150
    account.withdraw(30)
    assert account.balance == 120
```

3. **モジュールレベル**：
```python
# math_operations.py
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

# テスト
import math_operations

def test_math_operations():
    assert math_operations.add(5, 3) == 8
    assert math_operations.subtract(10, 4) == 6
```

### 抱いた新たな疑問
では、統合テストというのは、ユニットテストをメソッド・関数またはクラスレベルとしたとき、モジュールレベルのテストを統合テストと呼ぶこともできるのか？

## 統合テストの種類に関する調査
統合テストにはさまざまな種類があり、その具体的な分類については、さらに調査が必要であった。

### 調査結果
統合テストには以下のような体系的な分類があることを発見した：

**統合の進め方による分類**：
- トップダウンテスト
    - 上位モジュールから下位モジュールへと順にテストを進める方法。未完成の下位モジュールはテストスタブ（ダミーモジュール）で置き換える
- ボトムアップテスト
    - 下位モジュールから上位モジュールへと順にテストを進める方法。未完成の上位モジュールはテストドライバ（ダミーモジュール）で置き換える
- サンドイッチテスト（折衷テスト）
    - 上位モジュールと下位モジュール両方から結合を進める方法
- ビッグバンテスト
    - 全モジュール完成後に一気に結合してテストする方法

**統合先による分類**

- 結合テストA（ITA：Interface Test A）：
    - システム内で作成した機能同士を結合して、期待通りの動作となるか確認する。単体ではうまく動作していても、結合してみたらうまく動かないケースをチェック
- 結合テストB（ITB：Interface Test B）：
    - 結合先が外部システムとなる結合テスト。自分たちとは異なるシステムに繋げるため、思わぬ結果が出ることもある。原因調査や外部システムとの連携が必要

**テスト対象による分類**

- インターフェーステスト
    - モジュール間のデータ受け渡しが正しく行われるかを確認するテスト
- ブラックボックステスト
    - システムの内部構造を意識せず、入力に対する出力が正しいかを確認するテスト
- 業務シナリオテスト
    - 実際の業務で使用するシナリオを想定して、システムが正しく動作するかを確認するテスト
- 負荷テスト
    - システムに負荷をかけて、限界性能や安定性を確認するテスト

### まとめ
調査の結果、統合テストは少なくとも3つの観点（統合の進め方、統合先、テスト対象）から分類されることが判明した。ITAとITBについては、統合先によって明確に区別されており、ITAがシステム内機能同士の結合、ITBが外部システムとの結合という定義であることを確認した。

本題への示唆：
この調査により、統合テストには様々な分類が存在し、ITAのような機能単位での統合アプローチがあることが分かった。しかし、モジュールレベルのテストがユニットテストか統合テストかは、単純にITAの定義だけでは決定できない。なぜなら、モジュール内部でのテストは、そのモジュールの実装方法、依存関係の扱い方、テストの目的によって性質が大きく変わるからである。

文献によると結合テストの目的は「モジュール間のインターフェースの不具合やデータ連携の誤りを早期に発見し、システム全体の品質を向上させること」と定義されている。この定義から、統合テストの本質は「複数のコンポーネント間の相互作用」の検証にあることがわかる。

これらの調査結果を踏まえ、ユニットテストと統合テストの境界は「単一コンポーネントの機能検証」と「複数コンポーネント間の相互作用検証」という目的の違いで区別できる可能性が見えてきた。さらに、モジュールレベルのテストの分類については、モジュールの複雑さ、依存関係の扱い方、テストの目的などの要因を総合的に考慮する必要があることが、次の段階の調査で明らかになった。

## 第4段階：境界線の問題への取り組み
### モジュールテストの位置づけに関する探求
前段階の調査で、モジュールレベルのテストの分類が単純ではないことが明らかになった。ここでは、ユニットテストと統合テストの境界線を、特にモジュールテストに焦点を当てて明確化することを試みる。

### 一般的な定義の再確認
ソフトウェアテストの分野では、以下の定義が広く受け入れられている：

**ユニットテスト（単体テスト）**：
- テスト対象を他のコンポーネントから分離して実行する
- 外部依存はテストダブル（モック、スタブ、フェイクなど）で置き換える
- 高速で決定的（同じ入力に対して常に同じ結果）である
- 単一の振る舞いや機能に焦点を当てる

> [!info] テストダブルとは
> テストダブル（Test Double）は、テスト時に本物のオブジェクトの代わりに使用される代替品の総称である。映画の「スタントダブル」から名付けられた。
> 
> **主な種類：**
> - **モック（Mock）**: 期待される呼び出しを検証するオブジェクト。メソッドが正しく呼ばれたかをチェックする
> - **スタブ（Stub）**: 事前に定義された値を返すオブジェクト。テストに必要な最小限の実装を提供
> - **フェイク（Fake）**: 本物の簡易版実装。例：インメモリデータベース
> - **ダミー（Dummy）**: パラメータを埋めるためだけのオブジェクト。実際には使用されない
> - **スパイ（Spy）**: 実際のオブジェクトをラップし、呼び出しを記録する
> 
> **使用例：**
> ```python
> # スタブの例
> class EmailServiceStub:
>     def send(self, message):
>         return True  # 常に成功を返す
> 
> # モックの例
> email_mock = Mock()
> user_service = UserService(email_mock)
> user_service.register("user@example.com")
> email_mock.send.assert_called_once_with("Welcome!")
> ```

**統合テスト（結合テスト）**：
- 複数のコンポーネントを実際に結合して実行する
- 依存関係に対して実際のインタラクション（ネットワーク通信、ファイルI/O、プロセス間通信等）を発生させる
- 依存先は実サービス、スタブサーバー、LocalStack等の実環境相当のものを使用
- コンポーネント間のインタラクションを検証する
- ユニットテストより実行時間が長くなる傾向がある


> [!info] 統合テストにおける「実際のインタラクション」とは
> 統合テストの特徴は「実際のI/O操作を伴うこと」であり、依存先が本物のサービスである必要はない。
> 
> **統合テストで使用可能な依存先の例**：
> - **実サービス**: 本番環境のAWSサービス、外部API
> - **実環境相当**: テスト用Dockerコンテナ、開発環境のデータベース
> - **模擬環境**: LocalStack（AWS模擬）、スタブサーバー（API模擬）
> - **テストダブル**: 共有依存の場合のみ使用
> 
> **重要な判断基準**：
> - **ユニットテスト**: メモリ内のモック/スタブとのやり取り
> - **統合テスト**: 実際のネットワーク通信、ファイルI/O、プロセス間通信等を発生
> 
> つまり、LocalStackやスタブサーバーを使用する場合でも、TCP/IP通信やHTTP通信が発生するため「統合テスト」に分類される。


### モジュールテストの分類を決定する要因
モジュールレベルのテストがユニットテストか統合テストかを判断する際の、一般的に認められている基準：

1. **分離性（Isolation）**
   - テスト対象が他のコンポーネントから完全に分離されている → ユニットテスト
     - 例：全ての依存関係をテストダブルで置換し、テスト対象のみを検証
   - テスト対象と依存先コンポーネントが実際に結合している → 統合テスト
     - 例：データベース、ファイルシステム、他のサービスとの実際の連携を含む

2. **依存関係の扱い**
   - テスト対象の全ての外部依存をテストダブルで置換 → ユニットテスト
     - 例：UserServiceがDBとEmailServiceに依存する場合、両方をモックで置換
   - テスト対象の依存関係で一つ以上の実体を使用 → 統合テスト
     - 例：UserServiceのテストで実際のDBを使用（EmailServiceはモック）

3. **テストの範囲（Scope）**
   - テストが単一モジュール内の動作のみを検証 → ユニットテスト
     - 例：UserRepositoryクラス単体のメソッド動作を検証
   - テストがモジュール間の連携を検証 → 統合テスト
     - 例：UserService + UserRepository + DB の連携を検証

4. **実行環境**
   - テストがインメモリで完結 → ユニットテスト
     - 例：全ての処理がメモリ内のオブジェクト操作のみ
   - テストが実際のI/O操作（データベース、ファイルシステム、ネットワーク通信等）を伴う → 統合テスト
     - 例：実際のファイル読み書き、HTTP通信、DB接続を含む
     - 注：統合テストの依存先は実サービス、テスト用Docker、スタブサーバー、LocalStack等様々

### 実践的な判断基準
テスト駆動開発の第一人者であるKent Beckは、「ユニットテストは開発者が開発中に頻繁に実行できるテスト」と定義している。この観点から、以下の実践的な基準が導かれる：

- **実行時間**: ミリ秒単位で完了するならユニットテスト、秒単位以上かかるなら統合テスト
- **セットアップの複雑さ**: 特別な環境構築が不要ならユニットテスト、必要なら統合テスト
- **失敗時の原因特定**: 失敗原因が即座に特定できるならユニットテスト、調査が必要なら統合テスト

### モジュールテストの具体例による分類
```python
# ケース1: ユニットテストとして分類されるモジュールテスト
# calculation_module.py
class Calculator:
    def add(self, a, b):
        return a + b
    
    def multiply(self, a, b):
        return a * b

# テスト - 外部依存なし、高速実行
def test_calculator_module():
    calc = Calculator()
    assert calc.add(2, 3) == 5
    assert calc.multiply(4, 5) == 20

# ケース2: 統合テストとして分類されるモジュールテスト
# user_service.py
class UserService:
    def __init__(self, database, email_service):
        self.db = database
        self.email = email_service
    
    def create_user(self, user_data):
        user = self.db.save(user_data)
        self.email.send_welcome(user.email)
        return user

# テスト - 実際のデータベースとメールサービスを使用
def test_user_service_integration():
    db = RealDatabase()
    email = RealEmailService()
    service = UserService(db, email)
    user = service.create_user({"name": "Test", "email": "test@example.com"})
    assert db.find_by_email("test@example.com") is not None
```

### 重要な洞察
モジュールテストの分類は二元的ではなく、スペクトラムとして捉えるべきである。純粋なユニットテストと完全な統合テストの間には、様々な中間的な形態が存在する。この認識により、次の段階では依存関係の詳細な分析へと進むことになった。

## 第5段階：依存関係の体系的な調査
### テストにおける依存関係の分類
前段階でモジュールテストの分類における依存関係の重要性が明らかになったため、ここではテストにおける依存関係について体系的に調査した。

### 依存関係の基本的な分類
ソフトウェアテストの文献、特にVladimir Khorikovの「単体テストの考え方/使い方」では、依存関係を以下のように分類している：

**1. 共有依存（Shared Dependencies）**
- 定義：==複数のテストケース間で共有され、一つのテストが他のテストに影響を与える可能性がある==依存関係
- 特徴：
  - テストの並列実行時に問題を引き起こす
  - テストの実行順序に依存する結果を生む
  - テストの独立性を損なう
- 典型例：
  - 静的変数やシングルトンパターン
  - 共有データベース（複数のテストが同じテーブルを更新）
  - ファイルシステム上の共有ファイル
  - グローバルな設定や状態

**2. プライベート依存（Private Dependencies）**
- 定義：特定のテストケースのみが使用し、==他のテストに影響を与えない==依存関係
- 特徴：
  - テストごとに新しいインスタンスが作成される
  - 並列実行が安全
  - テストの独立性が保たれる
- 典型例：
  - ローカル変数やインスタンス変数
  - テストメソッド内で生成されるオブジェクト
  - インメモリデータベース（テストごとに独立）

**3. プロセス外依存（Out-of-Process Dependencies）**
- 定義：==アプリケーションのプロセス外で実行==される依存関係
- 特徴：
  - ネットワーク通信やプロセス間通信を伴う
  - パフォーマンスオーバーヘッドが大きい
  - 環境依存性が高い
- 典型例：
  - データベースサーバー
  - Web API
  - メッセージキュー
  - ファイルシステム

### 依存関係の組み合わせパターン
重要な発見として、これらの分類は相互に排他的ではなく、組み合わせが可能である：

1. **プロセス外かつ共有依存**
   - 例：本番データベースへの接続
   - 特徴：最もテストを複雑にする組み合わせ

2. **プロセス外だがプライベート依存**
   - 特徴：実体を使用しながらもテストの独立性を保てる
   - 具体例：
     - テストごとに作成される独立したDockerコンテナ（異なるコンテナ名/ポート）
     - テスト専用の一時ファイル（ユニークなファイル名で作成、テスト後削除）
     - 各テストで異なるポートを使用するテスト用HTTPサーバー
     - テストごとに独立したスキーマ/データベースを作成（例：test_user_service_20231201_142530）
     - 読み取り専用の外部API（状態を変更しないため共有しても安全）
     - テスト専用のS3バケットや名前空間（例：test-bucket-{uuid}）
     - インメモリで起動するRedis/Memcachedのテスト専用インスタンス
     - テストごとに独立したキューを作成するメッセージブローカー

3. **プロセス内かつ共有依存**
   - 例：静的変数、グローバル状態
   - 特徴：見落としやすいが問題を引き起こしやすい

4. **プロセス内かつプライベート依存**
   - 例：通常のインスタンス変数
   - 特徴：最も扱いやすい依存関係

### テスト戦略への影響
依存関係の種類によって、適切なテスト戦略が異なる：

**共有依存への対処**：
- 可能な限り回避する
- 回避できない場合は、テストの実行順序を制御
- テスト前後でのクリーンアップを徹底

**プロセス外依存への対処**：
- ユニットテストではテストダブルで置換
- 統合テストでは実体を使用
- プライベート化できる場合は積極的に行う

### 実践的な例
```python
# 共有依存の例（避けるべきパターン）
class UserCounter:
    _count = 0  # 静的変数（共有依存）
    
    @classmethod
    def increment(cls):
        cls._count += 1
        return cls._count

# プライベート依存の例（推奨パターン）
class UserService:
    def __init__(self):
        self._cache = {}  # インスタンス変数（プライベート依存）
    
    def get_user(self, id):
        if id not in self._cache:
            self._cache[id] = self._fetch_user(id)
        return self._cache[id]

# プロセス外依存をプライベート化する例
def test_with_isolated_database():
    # テストごとに独立したデータベースを作成
    with TestDatabase() as db:  # プロセス外だがプライベート
        service = UserService(db)
        # テストを実行

# より具体的な例：Dockerコンテナを使用
def test_with_docker_postgres():
    import uuid
    container_name = f"test_db_{uuid.uuid4()}"
    
    # テスト専用のPostgreSQLコンテナを起動
    container = docker.run(
        "postgres:14",
        name=container_name,
        port=get_random_port(),  # 他のテストと衝突しないポート
        env={"POSTGRES_DB": f"test_{uuid.uuid4()}"}
    )
    
    try:
        # このデータベースは他のテストから完全に独立
        db = connect_to_database(container.port)
        service = UserService(db)
        # テストを実行
    finally:
        container.stop()
        container.remove()
```

### 重要な洞察
依存関係の分類を理解することで、以下の戦略的判断が可能になった：
1. プロセス外依存であっても、それがプライベート依存であれば、統合テストで実体を使用することが実用的
2. 共有依存の識別と排除が、テストの信頼性向上の鍵
3. 依存関係の性質を正しく理解することで、モック/スタブと実体の使い分けが明確になる

この理解を基に、次の段階では具体的な実装戦略の検討へと進むことになった。

## 第6段階：バックエンドアーキテクチャにおけるテスト戦略の確立
### 4層アーキテクチャでのテスト境界の適用
前段階までの依存関係分析を踏まえ、バックエンドの4層アーキテクチャ（Presentation、Application、Domain、Infrastructure）における具体的なテスト戦略を確立する。

### 各層の特性とテスト方針

#### **Domain層（ドメイン層）**
- 特性：外部依存がなく、純粋なビジネスロジック
- テスト方針：純粋なユニットテスト
- 推奨アプローチ：
  - 全ての依存をテストダブルで置換
  - 高速実行（ミリ秒単位）
  - 高いカバレッジを目標（90%以上）
  - 各メソッド・クラスを完全に分離してテスト

#### **Application層（アプリケーション層）**
- 特性：Domain層とInfrastructure層への依存
- テスト方針：ハイブリッドテスト（部分的統合）
- 推奨アプローチ：
  - Domain層は実体を使用（プロセス内かつプライベート依存）
  - Infrastructure層はテストダブルで置換
  - ユースケースの完全性を検証
  - ビジネスフローの正確性に焦点
- **特殊ケース - Authorizer**：
  - 認可ポリシーロジックは実体を使用（Domain的性質）
  - Repository依存はテストダブルで置換
  - セキュリティの正確性を最優先に検証

> [!info] Application層での「ハイブリッドテスト」とは
> Application層のテストは、技術的にはユニットテストの特徴を持ちながら、複数のコンポーネント（ApplicationService + Domain）を組み合わせる部分的な統合性を持つ。
> 
> **ユニットテストの特徴**：
> - 高速実行（秒単位以下）
> - 外部依存（Infrastructure）をテストダブルで置換
> - テスト間の独立性を保持
> 
> **統合テストの特徴**：
> - 複数のコンポーネント（ApplicationService、DomainService、Entity、ValueObject）を実際に連携
> - Domain層の実体を使用することで、ビジネスロジックの完全性を検証
> 
> **具体例**：
> ```python
> # Application層のハイブリッドテスト例
> def test_user_registration_use_case():
>     # Infrastructure層はモック（ユニットテストの特徴）
>     user_repo_mock = Mock()
>     email_service_mock = Mock()
>     
>     # Domain層は実体を使用（統合テストの特徴）
>     domain_service = UserDomainService()  # 実体
>     
>     # ApplicationServiceをテスト
>     use_case = UserRegistrationUseCase(
>         user_repo_mock, 
>         email_service_mock, 
>         domain_service
>     )
>     
>     # ユースケース全体の流れを検証
>     result = use_case.execute("test@example.com", "password123")
>     
>     # Domain層のビジネスルールが正しく適用されているかを検証
>     assert result.is_success
>     user_repo_mock.save.assert_called_once()
>     email_service_mock.send_welcome.assert_called_once()
> ```
> 
> このアプローチにより、Infrastructure層の複雑さを排除しながら、Application層とDomain層の連携を実際に検証できる。
> 


#### **Authorizerの特殊なテスト戦略**：
Authorizerは認可という重要なセキュリティ機能を担うため、特別な配慮が必要である。

```typescript
describe('ProcessOperationAuthorizer', () => {
  let authorizer: ProcessOperationAuthorizer;
  let userRepoMock: jest.Mocked<IUserRepository<any>>
  let siteMembersRepoMock: jest.Mocked<ISiteMembersRepository<any>>;
  beforeEach(() => {
    // Infrastructure層（Repository）はモック
    userRepoMock = createMock<IUserRepository<any>>();
    siteMembersRepoMock = createMock<ISiteMembersRepository<any>>();
    
    authorizer = new ProcessOperationAuthorizer(
      userRepoMock,
      systemUserRepoMock,
      siteRepoMock,
      siteMembersRepoMock
    );
  });
  
  test('should allow site member to save process operation', async () => {
    // Given: サイトメンバーのユーザー
    const userId = new UserId('user-123');
    const processOp = new ProcessOperation(/* ... */);
    
    // モックの設定（具体的なデータパターンをテスト）
    userRepoMock.findById.mockResolvedValue(mockUser);
    siteMembersRepoMock.isMember.mockResolvedValue(true);
    
    // When: 保存権限をチェック
    const result = await authorizer.isAllowed(userId, 'save', processOp);
    
    // Then: 許可される
    expect(result).toBeInstanceOf(Allowed);
    expect(result.resource).toBe(processOp);
  });
  
  test('should deny non-member to save process operation', async () => {
    // セキュリティ要件のため、拒否パターンも必ずテスト
    siteMembersRepoMock.isMember.mockResolvedValue(false);
    
    const result = await authorizer.isAllowed(userId, 'save', processOp);
    
    expect(result).toBeInstanceOf(Denied);
  });
});
```

**Authorizerテストの重要な点**：
1. **セキュリティの完全性**: 許可・拒否の両パターンを必ずテスト
2. **ポリシーロジックの検証**: `AuthorizationPolicy`や`SiteAffiliationRule`は実体を使用
3. **データアクセスの分離**: Repository層はモック化で高速テストを実現
4. **境界値テスト**: 権限の境界ケース（期限切れ、無効なリソース等）を重点検証

#### **Infrastructure層（インフラストラクチャ層）**
- 特性：外部システム（DB、AWS、外部API等）への依存
- テスト方針：**目的別の段階的アプローチ**

**Infrastructure層のテスト戦略マトリックス**

| 依存先              | ユニットテスト | ITa（システム内統合）         | ITb（外部統合）  |
| ---------------- | ------- | -------------------- | ---------- |
| **システム内DB**      | モック     | Docker/TestContainer | 実DB（非本番）   |
| **AWS Services** | モック     | LocalStack           | AWS（開発環境）  |
| **外部API（信頼性高）**  | モック     | スタブサーバー              | 実API（制限付き） |
| **外部API（不安定）**   | モック     | スタブサーバー              | スタブサーバー    |

**判断基準の詳細**
**ユニットテストレベル**:
**目的**: インターフェース実装の正確性検証
**手法**: 全て`モック/スタブ`を使用
```typescript
// ユニットテスト例：Repository実装
describe('UserRepository', () => {
  test('should return user when found in database', async () => {
    // DBConnectionはモック
    const mockConnection = {
      query: jest.fn().mockResolvedValue([{ id: '123', name: 'Test' }])
    };
    
    const repo = new UserRepository(mockConnection);
    const user = await repo.findById('123');
    
    expect(user).toBeDefined();
    expect(mockConnection.query).toHaveBeenCalledWith(
      'SELECT * FROM users WHERE id = ?', ['123']
    );
  });
});

// ユニットテスト例：外部APIクライント
describe('OpenAIClient', () => {
  test('should format request correctly', async () => {
    // HTTPクライアントはモック
    const mockHttp = {
      post: jest.fn().mockResolvedValue({ data: { choices: [...] } })
    };
    
    const client = new OpenAIClient(mockHttp);
    const result = await client.generateText('prompt');
    
    expect(mockHttp.post).toHaveBeenCalledWith('/completions', {
      model: 'gpt-3.5-turbo',
      messages: [{ role: 'user', content: 'prompt' }]
    });
  });
});
```
**ITa（システム内統合テスト)**:
**目的**: システム内コンポーネント間の連携検証
**手法**: `プライベート実体 + スタブサーバー`

```typescript
// ITa例：DB統合テスト
describe('UserRepository Integration', () => {
  let testDB: TestDatabase;
  
  beforeEach(async () => {
    // テスト専用のDockerコンテナを起動
    testDB = await TestDatabase.start();
  });
  
  test('should persist and retrieve user correctly', async () => {
    const repo = new UserRepository(testDB.connection);
    const user = new User('123', 'test@example.com');
    
    await repo.save(user);
    const retrieved = await repo.findById('123');
    
    expect(retrieved).toEqual(user);
  });
});

// ITa例：外部APIスタブサーバー
describe('WeatherService Integration', () => {
  let stubServer: WireMockServer;
  
  beforeEach(() => {
    // スタブサーバーを起動
    stubServer = new WireMockServer();
    stubServer.stubFor(
      get('/weather?city=Tokyo')
        .willReturn(okJson({ temp: 25, condition: 'sunny' }))
    );
  });
  
  test('should parse weather data correctly', async () => {
    const service = new WeatherService(stubServer.baseUrl);
    const weather = await service.getWeather('Tokyo');
    
    expect(weather.temperature).toBe(25);
    expect(weather.condition).toBe('sunny');
  });
});
```

**ITb（外部統合テスト)**:
**目的**: 実際の外部システムとの連携検証
**手法**: **制御された実環境**または**限定的実接続**

```typescript
// ITb例：AWS S3統合テスト（開発環境）
describe('S3FileStorage ITb', () => {
  let s3Client: S3Client;
  
  beforeEach(() => {
    // 開発環境のS3に接続
    s3Client = new S3Client({
      region: 'ap-northeast-1',
      credentials: testCredentials,
      endpoint: 'https://s3.dev.yourcompany.com' // 開発環境
    });
  });
  
  test('should upload and download file correctly', async () => {
    const storage = new S3FileStorage(s3Client);
    const content = 'test content';
    
    const key = await storage.upload(content, 'test.txt');
    const downloaded = await storage.download(key);
    
    expect(downloaded).toBe(content);
  });
  
  afterEach(async () => {
    // テストデータをクリーンアップ
    await cleanupTestFiles();
  });
});
```

**外部API別の判断基準**
- **信頼性の高い外部API（例：大手天気API）**
	- **ITa**: スタブサーバーで様々なレスポンスパターンをテスト
	- **ITb**: 実APIで基本的な接続のみテスト（レート制限考慮）
- **重要だが不安定な外部API（例：OpenAI）**
	- **ITa**: スタブサーバーで詳細なレスポンスパターンをテスト
	- **ITb**: 開発用APIキーで最小限のテスト、またはスタブサーバー継続使用

**システム内AWS Services**
- **ITa**: LocalStackで完全な機能テスト
- **ITb**: 開発環境で実際のAWSサービステスト

**実装上の注意点**

1. **環境の分離**: テスト環境が本番に影響しない設計
2. **データクリーンアップ**: テスト後の確実なデータ削除
3. **レート制限対応**: 外部APIの制限を考慮したテスト設計
4. **フェイルセーフ**: 外部サービス障害時のテスト継続性
5. **コスト管理**: 従量課金サービスのテストコスト制御

#### **Presentation層（プレゼンテーション層）**
- 特性：HTTPリクエスト/レスポンス、認証・認可
- テスト方針：統合テスト（APIテスト）
- 推奨アプローチ：
  - Application層以下は実体を使用
  - Infrastructure層は可能な限りプライベート化
  - エンドツーエンドのHTTPフローを検証

### 実践的な判断フローチャート
```
テスト対象の特定
↓
外部依存の識別
↓
依存関係の分類
├─ プロセス内 & プライベート → ユニットテスト（実体使用）
├─ プロセス内 & 共有 → ユニットテスト（テストダブル使用）
├─ プロセス外 & プライベート → 統合テスト（実I/O操作あり）*
└─ プロセス外 & 共有 → 統合テスト（テストダブル使用）

* 依存先は実サービス、Docker、スタブサーバー、LocalStack等
```

### 層別テスト戦略マトリックス
| 層              | 主要テストタイプ | Domain依存 | Infrastructure依存 | 実行環境    | 重点検証項目   |
| -------------- | -------- | -------- | ---------------- | ------- | -------- |
| Domain         | ユニット     | -        | テストダブル           | インメモリ   | ビジネスロジック |
| Application    | ハイブリッド   | 実体       | テストダブル           | インメモリ   | ユースケース   |
| Infrastructure | 統合       | 実体       | プライベート実体         | Docker等 | 外部連携     |
| Presentation   | 統合(API)  | 実体       | プライベート実体         | Docker等 | HTTPフロー  |
|                |          |          |                  |         |          |

> [!note] 主要テストタイプについて
> 上記は各層で**推奨される主要なテストタイプ**を示している。ただし、必要に応じて他のテストタイプも実施可能である。
> 
> 例えば：
> - **Infrastructure層**でも、Repository実装の単体ロジック検証のためユニットテスト（全依存をモック）を実施できる
> - **Domain層**でも、複雑なビジネスルールの場合は軽い統合テストを実施できる
> - **Presentation層**でも、コントローラーの単体ロジックをユニットテストできる
> 
> プロジェクトの要件や複雑さに応じて、適切なテストタイプを柔軟に選択することが重要である。

# リサーチ結果：体系的なテスト戦略

## ソフトウェアテストの基本概念

### ユニットテスト
**定義**: プログラムの最小単位（関数、メソッド、クラスなど）を個別にテストする手法

**目的**: 個々のコンポーネントが期待通りに動作することを確認する

**特徴**:
- 迅速で実行が容易
- バグの早期発見に役立つ
- コードの品質向上とリファクタリングの支援
- 開発中、頻繁に実行される

### 統合テスト
**定義**: 複数のコンポーネントやモジュールを組み合わせてテストする手法

**目的**: コンポーネント間の相互作用や統合された機能が正しく動作することを確認する

**重要な観点**: 統合テストは単に「コンポーネントが繋がっているかを確認する」だけではなく、**統合された状態での機能やビジネスロジックの正しさ**を検証する。つまり、複数のコンポーネントが連携して期待される振る舞いを実現できているかを確認することが本質である。

**特徴**:
- より複雑で、時間がかかる場合がある
- システム全体の動作を確認できる
- インターフェースや依存関係の問題を発見できる
- 個々のコンポーネントの開発後、または定期的に実行される

### 整理した主な違い
1. **スコープ**: ユニットテストは個々の部品、統合テストは複数コンポーネントが連携した機能全体をテスト
2. **複雑さ**: ユニットテストはシンプル、統合テストはより複雑
3. **実行速度**: ユニットテストは高速、統合テストはより時間がかかる
4. **発見できる問題**: ユニットテストは個々の機能の問題、統合テストはコンポーネント間の相互作用や統合された機能の問題を発見

## 調査した統合テストの種類

### 基本的なアプローチ
1. **ビッグバンテスト（Big Bang Testing）**
   - 全てのモジュールを一度に統合してテストする手法
   - 小規模なシステムに適している
   - 欠点：障害の原因特定が困難

2. **トップダウンテスト（Top-Down Testing）**
   - 上位モジュールから下位モジュールへと順次テストを行う
   - 主要な機能やインターフェースを早期に検証できる
   - 下位モジュールのスタブ（仮の実装）が必要

3. **ボトムアップテスト（Bottom-Up Testing）**
   - 下位モジュールから上位モジュールへと順次テストを行う
   - 基本的な機能から確実にテストできる
   - 上位モジュールのドライバ（テスト用の呼び出し機能）が必要

4. **サンドイッチテスト（Sandwich Testing）**
   - トップダウンとボトムアップを組み合わせた手法
   - 複雑なシステムに適している
   - 中間層のテストが重複する可能性がある

### 増分的統合テスト（Incremental Integration Testing）
モジュールを徐々に追加しながらテストを行う手法。エラーの特定が容易である。

**サブタイプ**:
- **ITa（Integration Testing a）**: システム内機能同士の統合。複数のコンポーネントが連携して実現する機能やユースケースを検証
- **ITb（Integration Testing b）**: 外部システムとの統合。他システムやサービスとの連携部分を検証
- **ITc（Integration Testing c）**: システム全体を統合。システム全体としての機能を検証

## 分析したユニットテストの対象

### 注意点
- 単一の責任原則に従い、各ユニットは明確で単一の機能を持つべき
- 外部依存（データベース、ファイルシステムなど）はモックやスタブを使用して分離
- テストは独立しており、他のテストや外部状態に依存しないようにする

## 統合テストとユニットテストの境界

### モジュールレベルのテストの位置づけ
モジュールレベルのテストは、ユニットテストと統合テストの中間に位置することがあり、その分類は以下の要因によって変わる：

1. **モジュールの複雑さと範囲**
   - 単一の責任を持つ小さなモジュール → ユニットテストに近い
   - 複数の関連機能を含む大きなモジュール → 統合テストに近い

2. **依存関係の扱い**
   - 外部依存をモックやスタブで置き換える → ユニットテストの特徴
   - 一つ以上の依存で実際のI/O操作を発生させる（実サービス、Docker、LocalStack、スタブサーバー等） → 統合テストの特徴

3. **テストの目的**
   - 個々の機能の正確性を確認 → ユニットテスト
   - コンポーネント間の相互作用や統合された機能の振る舞いを確認 → 統合テスト

4. **テストの粒度とスコープ**
   - 細かい粒度（メソッド/クラス） → ユニットテスト
   - より広いスコープ（複数のクラスやサブシステム） → 統合テスト

### 実際の適用
1. **拡張されたユニットテスト**：複数の密接に関連したクラスや関数をまとめてテストする場合
2. **小規模な統合テスト**：モジュール内の複数のコンポーネントの相互作用をテストする場合
3. **コンポーネントテスト**：ユニットテストと統合テストの中間カテゴリー

## 分析したテストにおける依存関係の種類

### 共有依存（Shared Dependencies）
**定義**: 複数のテストケース間で共有される依存関係
**特徴**: 同時実行時に相互に影響を与える可能性がある
**例**:
- staticフィールド変数
- グローバル変数
- 共有データベース
- ファイルシステム上の共有ファイル

### プライベート依存（Private Dependencies）
**定義**: 特定のテストケースにのみ影響を与える依存関係
**特徴**: 他のテストケースとは独立して動作する
**例**:
- ローカル変数
- テストケース専用のインメモリデータベース

### プロセス外依存（Out-of-Process Dependencies）
**定義**: アプリケーションのプロセス外で動作する依存関係
**特徴**: 共有依存である場合もあるが、必ずしもそうとは限らない
**例**:
- データベース（共有依存になる場合が多い）
- 外部APIサービス
- メッセージキュー

### プロセス外依存の扱い
**実コンポーネントを使用できる条件**:
1. テスト間の独立性が保たれる場合
2. テストの再現性が確保できる場合
3. テスト実行速度に大きな影響がない場合

**実コンポーネントを使用する利点**:
- より現実的なテスト環境
- 統合の問題を早期に発見可能
- モックやスタブによる誤った動作の回避

**実コンポーネントを使用する際の注意点**:
- テストの複雑性が増す可能性
- テスト環境のセットアップと管理が必要
- テスト実行時間が長くなる可能性

### 具体例
1. **読み取り専用APIサービス**
   - 共有依存ではない（データが変更されないため）
   - 実際のAPIを使用してテスト可能

2. **テストごとに分離されたDockerコンテナ上のデータベース**
   - 共有依存ではない（各テストが独立した環境を持つため）
   - 実際のデータベースを使用してテスト可能

3. **キャッシュサーバー（例：Redis）**
   - テスト前に毎回クリアする場合、共有依存とはならない
   - 実際のキャッシュサーバーを使用してテスト可能

## 提案するモジュールテストにおける依存関係の扱い

### 基本的な考え方
モジュールテストでは、プロセス外依存が共有依存でない場合、以下の理由から実体を使用することを検討すべきである：

1. 現実的なテスト環境の提供
2. 統合の問題の早期発見
3. モックやスタブによる誤った動作の回避

### 考慮すべき要因
**テストの目的**:
- 単体の機能テスト → モックやスタブを使用
- 統合的な動作確認 → 実際の依存関係を使用

**テストの実行速度**:
- 高速な実行が必要 → モックやスタブを使用
- 実行速度よりも現実性を重視 → 実際の依存関係

**テスト環境の管理**:
- 環境のセットアップが複雑 → モックやスタブを使用
- 環境の管理が容易 → 実際の依存関係を使用

**テストの再現性**:
- 完全な制御が必要 → モックやスタブを使用
- 現実的な挙動が重要 → 実際の依存関係を使用

### 推奨アプローチ
1. **段階的なアプローチ**
   - 単体テスト → モックやスタブを使用
   - モジュールテスト → 可能な限り実際の依存関係を使用
   - 統合テスト → ほぼ全ての依存関係で実体を使用

2. **ハイブリッドアプローチ**
   - 重要な依存関係 → 実体を使用
   - 副次的な依存関係 → モックやスタブを使用

3. **コンテキストベースのアプローチ**
   - 開発初期段階 → モックやスタブを多用
   - 開発後期／保守段階 → 実体を多用

# リサーチ結論：バックエンドテスト戦略の検討材料

## 仮説検証の結果

**仮説1の検証結果**: ✅ **確認済み**
ユニットテストと統合テストの境界は、依存関係の種類（共有/プライベート、プロセス内/外）とその扱い方によって明確に定義できることを実証した。

**仮説2の検証結果**: ✅ **リサーチ完了**
依存関係の体系的分類により、以下の選択指針案を整理：
- プロセス内 & プライベート → 実体使用のユニットテスト
- プロセス内 & 共有 → テストダブル使用のユニットテスト
- プロセス外 & プライベート → 実I/O操作ありの統合テスト（依存先は実サービス、Docker、スタブサーバー、LocalStack等）
- プロセス外 & 共有 → テストダブル使用またはスタブサーバの統合テスト 

**仮説3の検証結果**: ✅ **確認済み**
モジュールテストの分類は、分離性、依存関係の扱い、テスト範囲、実行環境の4要因によって動的に決定されることを確認した。

## バックエンドアプリケーションでの適用指針

### 層別テスト戦略の提案
1. **Domain層**: 純粋ユニットテスト（100%テストダブル）
2. **Application(Usecase)層**: ハイブリッド（Domain実体 + Infrastructure テストダブル）
3. **Infrastructure層**: 統合テスト（プライベート実体中心）
4. **Presentation(Route)層**: 統合(API)テスト（全層実体、プライベート環境）

### 実践的判断基準
- **独立性の確保**: 各テストが他のテストに影響しない設計
- **実行速度の最適化**: ユニット < 軽統合 < 統合の階層構造
- **現実性とのバランス**: 重要な外部連携は実体で検証
- **保守性の確保**: 明確な境界線により、テスト意図の明確化


## その他のアイデア・選択肢募集中 💭

[まだ考えていない選択肢があれば、コメントで教えてください]

## 🔗 関連情報・参考資料

[参考になる情報があれば記載してください]

- **関連するADR**:
- **関連するDesign Doc**:
- **関連するLinearタスク**:
- **参考記事・ドキュメント**:
    - [単体テストの考え方/使い方](https://www.amazon.co.jp/%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%81%AE%E8%80%83%E3%81%88%E6%96%B9-%E4%BD%BF%E3%81%84%E6%96%B9-Vladimir-Khorikov/dp/4839981728)
    - [なぜ、統合テストは重要なのだろうか](https://zenn.dev/ignorant_kenji/articles/6f740feabf6f30#%E3%81%AA%E3%81%9C%E3%80%81%E7%B5%B1%E5%90%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E9%87%8D%E8%A6%81%E3%81%AA%E3%81%AE%E3%81%A0%E3%82%8D%E3%81%86%E3%81%8B)
- **過去の似たような議論**: [リンク]
- **関連するシステム・サービス**: [名前とリンク]

---

## 💬 ディスカッション・コメント

[この下にコメントが追加されます]

- kato
	- ~~Honoのappのtestを使用するとDBだけテストダブルという実装ができない~~
	- ⇨ application層とpresentation層を読み違えていた

## 📝 検討過程メモ

[検討中に気づいたことや、議論の流れをメモしてください]

## ✅ 結論・決定事項（検討完了後に記載）

[検討が完了したら、ここに結論を記載してください]

本ドキュメントはリサーチに重点を置いているため、決定事項は記載しない

## 決定内容

[何が決まったのか]

## 決定理由

[なぜその決定に至ったのか]

## 反対意見・懸念事項

[決定に対する懸念や反対意見があれば記載]

## 次のアクション

なし。

- [ ]  [具体的なアクション1]
- [ ]  [具体的なアクション2]
- [ ]  ADR作成の必要性
- [ ]  Design Doc作成の必要性
- [ ]  Linearタスク作成: [タスクへのリンク]

 