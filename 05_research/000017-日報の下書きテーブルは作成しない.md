---
type: note
---
## 📜 文脈・背景

日報機能の実装において、下書き機能をどのように実現するかの設計検討が必要となった。主な選択肢として以下の2つのアプローチが検討された：

1. **下書き専用テーブル作成**: `WorkDailyReportDrafts`テーブルを別途作成し、下書きと送信済みを完全に分離する
2. **単一テーブル + ステータス管理**: `WorkDailyReports`テーブル内で`status`フィールド（draft/sent）により状態を管理する

下書きテーブル作成には以下のメリットが存在することが確認された：

- データライフサイクルの違いによる最適化（90日自動削除など）
- スキーマとインデックス戦略の個別最適化
- 状態遷移の明確化と誤操作防止
- 監査・バックアップ戦略の差別化
- 将来的な機能拡張性の向上

一方で、現在の要件と開発・運用の現実的な制約も考慮する必要があった。

## 🎨 対応案

### 案1: 下書きテーブル作成

- `WorkDailyReportDrafts`と`WorkDailyReports`を分離
- 関連テーブルも全て下書き用を作成
- データ移行ロジックの実装が必要

### 案2: 単一テーブル + ステータス管理

- `WorkDailyReports`テーブル内で状態管理
- `status`フィールドで draft/sent を区別
- 同一レコード内での状態遷移

## 🚀 決定

**日報機能では下書き専用テーブルを作成せず、単一テーブル内でのステータス管理を採用する。**

この決定の根拠：

- DDDの観点から「日報」は単一の集約ルートであり、draft/sentは状態の違いに過ぎない
- 現在の要件では下書きの長期保存や複雑な管理機能は求められていない
- 工事現場の日報は通常その日のうちに送信されるため、複雑な下書き管理は不要
- 開発・運用コストの削減とシステムの簡素化を優先
- 履歴の連続性（下書き→送信の流れ）が一つのエンティティで追跡可能

## 🪞 結果・影響

### プラスの結果

- **開発効率の向上**: テーブル数の削減により実装・テストコストが削減される
- **運用の簡素化**: 単一テーブルによりクエリ・監視・バックアップが簡単になる
- **データ整合性**: 同一レコード内での状態変更により整合性リスクが軽減される
- **履歴追跡**: 下書きから送信までの流れが一つのエンティティで完結する

### マイナスの結果

- **データライフサイクル管理の制約**: 下書きの自動削除機能の実装が複雑になる
- **スキーマ最適化の制約**: 下書き時と送信済み時で異なる制約を適用できない
- **将来の拡張性**: 下書き固有の高度な機能追加時にリファクタリングが必要になる可能性

### 技術的影響

- `WorkDailyReports`テーブルに`status`、`sentAt`フィールドを追加
- 下書き関連の全ての中間テーブル設計を削除
- APIエンドポイント設計がシンプルになる

## 🍜 今後の検討事項

- **下書きデータの定期削除機能**: 一定期間経過した未送信の下書きの自動削除ロジック実装
- **パフォーマンス監視**: 単一テーブルでの運用における検索・更新性能の継続的な監視
- **将来的な要件変化への対応**: 下書きの共同編集やバージョン管理機能が求められた場合の設計見直し
- **データアーカイブ戦略**: 送信済み日報の長期保存とアーカイブ方針の策定


