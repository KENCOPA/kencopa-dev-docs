---
type: note
---
基本設計をもとに実装を進めていくにあたり、設計の詳細を示す。

# 実装方針
1. データ取得とキャッシュの一元化:
- データ取得ライブラリ TanStack Query (react-query) を活用し、バックエンドAPI (GET /api/v1/protected/tenant-context/labels) からのラベルデータ取得とキャッシュ管理を一元化
	- これにより、不要なAPI呼び出しを削減
2. グローバルな状態共有 (Context API):
- LabelProvider というReactコンポーネントを作成し、アプリケーションのテナントコンテキストのルート (/src/app/(tenant-context)/layout.tsx) を囲む
	- これにより、LabelProvider内で取得・キャッシュされたラベルデータが、配下のすべてのコンポーネントで利用可能
3. コンポーネントからのシンプルな利用 (Custom Hooks):
- UIコンポーネントがラベルデータを直接扱うのではなく、useLabel というカスタムフックを通じてアクセス
- このフックは、ラベルの表示名を取得するためのシンプルな関数 t('key') を提供し、コンポーネント側はデータ取得の複雑なロジックを意識する必要がなくなります。
4. データ更新とUIの自動反映:
- ラベルの更新 (useUpdateLabel) やリセット (useResetLabel) を行うための専用フックを持つ
	- これらのフックは、更新APIの実行後、TanStack Query のキャッシュを無効化する責務を持つ。
	- キャッシュが無効化されると、TanStack Queryが自動的にデータを再取得し、UIが最新の状態に自動で更新される。

# custom hooksの中身
カスタムフックの具体的な実装を以下に示す。

a. ラベル取得・管理フック: useLabels.tsx
これがラベル管理システムの主要部分である。

- useGetLabels: useQuery を使い、ラベル一覧APIを呼び出して結果をキャッシュする。キャッシュキーとして ["labels"] を使用する。
- LabelProvider: useGetLabels から取得したデータを、高速に検索できる Map 形式に変換し、Context を通じて配下のコンポーネントに提供する。
- useLabel: 各コンポーネントが LabelProvider のデータ（特に t 関数）にアクセスするための窓口となるフックである。

b. ラベル更新フック: useUpdateLabel.tsx
ラベル設定画面の「保存」ボタンなどで使用される、データ書き込み専用のフック

- useMutation を使い、ラベル更新API (PUT /.../labels/:labelKey) を呼び出すロジックをカプセル化。
- API呼び出しが成功した後の onSuccess コールバックです。ここで queryClient.invalidateQueries({ queryKey: ["labels"] }) を実行し、ラベル一覧のキャッシュを意図的に無効化。
- キャッシュが無効になると、useGetLabels が自動的に最新のデータを再取得し、UIが自動で更新される。

## 呼び出し側の使い方
作成したフックを実際のコンポーネントでどのように使うか

1. Providerの設置
まず、アプリケーションのテナントコンテキストのレイアウトで、LabelProvider を設置する。これにより、配下の全ページで useLabel が利用可能にする。(TanStackProviderは設置済み)
2. 一般的なコンポーネントでのラベル表示
useLabel を使って、ハードコードされた文字列の代わりに t 関数で表示名を取得する。
3. ラベル設定画面での更新処理
useUpdateLabel を使って、更新処理を呼び出す。UIコンポーネントはAPI通信やキャッシュ管理を意識しない。