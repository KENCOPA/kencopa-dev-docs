---
type: note
tags:
- '#ai/ref'
---
# 概要

AOA型工程表エディタの開発・検証フェーズにおいて、パフォーマンス問題の早期発見と継続的監視を行うためのデバッグツールを構築する。本ツールはデバッグモード時のみ動作し、開発者がリアルタイムでパフォーマンス指標を監視・分析できる機能を提供する。

# 測定対象とその目的

本デバッグツールでは以下の指標を測定する：

- **FPS (Frames Per Second)** - アニメーション・描画のフレームレート
- **メモリ使用量** - JSヒープサイズ、メモリリーク検出
- **処理時間** - 描画・操作・更新処理の実行時間
- **DOM/SVG要素数** - タスク・アノテーション要素の総数
- **イベント処理性能** - マウス・キーボード操作の応答時間
- **Undo/Redo性能** - 履歴管理と状態復元の処理時間

## FPS (Frames Per Second)
**測定する理由**: 
- ユーザーの操作感に直結する最重要指標
- アニメーション・描画処理の性能劣化を即座に検出
- フレーム落ちによるUX悪化を防止

**測定内容**:
- **測定タイミング**: アニメーションループ（ブラウザの描画タイミング）での連続測定
- **算出方法**: 1秒間のフレーム数をカウント
- **表示形式**: リアルタイム数値、色分けステータス表示（緑/黄/赤）

## メモリ使用量
**測定する理由**:
- メモリリークの早期発見（長時間操作での急激な増加）
- ブラウザクラッシュ・動作不安定の予防
- 大量データ処理時のメモリ効率検証

**測定内容**:
- **測定項目**: `performance.memory`API（usedJSHeapSize, totalJSHeapSize, jsHeapSizeLimit）
- **測定間隔**: 5秒間隔での定期取得
- **表示形式**: MB単位、時系列グラフ、増加傾向アラート

## 処理時間
**測定する理由**:
- 重い処理によるメインスレッドブロック検出
- ユーザー操作に対するレスポンス性能の定量評価
- 処理効率の改善ポイント特定

**測定内容**:
- **測定項目**: 描画処理、ドラッグ操作、タスク生成・更新、DOM/SVG要素操作、Undo/Redo処理
- **測定方法**: `performance.now()`による高精度時間計測
- **表示形式**: ms単位、統計情報（平均・最大・P95）、警告アラート

## DOM/SVG要素数
**測定する理由**:
- 大量要素による描画性能劣化の監視
- メモリ使用量増加要因の特定
- スケーラビリティ限界の把握

**測定内容**:
- **測定項目**: AOAタスク要素、アノテーション要素（テキスト・図形・画像）、総DOM要素数、SVGグループ数
- **測定タイミング**: `MutationObserver`による要素追加・削除時の自動監視
- **表示形式**: 要素種別ごとのカウント、増減履歴、閾値警告

## イベント処理性能
**測定する理由**:
- ユーザー操作の応答性確保
- イベントハンドラーの処理効率検証
- 操作遅延による体験悪化の防止

**測定内容**:
- **測定項目**: マウスイベント（click, mousemove等）、キーボードイベント、タッチイベント（将来対応）
- **測定方法**: キャプチャフェーズでのイベント処理時間計測
- **表示形式**: イベント種別ごとの統計、異常値アラート（100ms超過時）

## Undo/Redo性能
**測定する理由**:
- 大量データ変更時の状態復元時間の監視
- メモリ使用量増加（履歴データ蓄積）の追跡
- ユーザビリティに直結する操作応答性の確保

**測定内容**:
- **測定項目**: Undo実行時間、Redo実行時間、履歴データサイズ、履歴保存処理時間
- **測定方法**: 操作開始から状態復元完了までの時間計測
- **表示形式**: 実行時間統計、履歴メモリ使用量、操作回数カウント

# デバッグモード機能

## パフォーマンスダッシュボード
- **表示位置**: 画面右上または左下のオーバーレイ
- **表示内容**:
  - FPS（リアルタイム）
  - メモリ使用量（現在値・推移）
  - 描画処理時間（平均・最大）
  - 要素数（タスク・アノテーション）
  - 警告・エラーメッセージ

## デバッグモード切り替え
- **有効化方法**:
  - URLパラメータ: `?debug=true`
  - キーボードショートカット: `Ctrl+Shift+D`
  - 設定パネルからの切り替え
- **非表示条件**: 本番環境では自動的に無効化

## パフォーマンス記録・エクスポート
- **記録形式**: JSON形式でのパフォーマンスログ
- **エクスポート機能**: CSV/JSON形式でのデータダウンロード
- **記録項目**:
  - タイムスタンプ
  - FPS値
  - メモリ使用量
  - 処理時間
  - ユーザー操作ログ

# 実装アプローチ

## アーキテクチャ概要
パフォーマンス監視デバッグツールは以下の構成で実装する：

- **PerformanceMonitor**: 各測定クラスを統合管理するメインクラス
- **個別測定クラス**: FPSCounter, MemoryMonitor, TimingMonitor, ElementCounter, EventPerformanceMonitor
- **DebugDashboard**: UI表示・制御を担当
- **DataExporter**: 測定データのエクスポート機能

## 既存プロトタイプへの統合方針
**Canvas版 (canvas-grid-snapping-annotation.html)**:
- 既存のFPS計測機能（1498-1512行）を拡張
- Canvas描画処理時間の測定を追加
- DOM要素監視とメモリ監視の統合

**SVG版 (svg-grid-snapping-annotation.html)**:
- 既存のFPS計測機能（402-427行）を拡張
- SVG要素操作処理時間の測定を追加
- SVG要素数の詳細監視

# 技術検討事項

## 測定オーバーヘッドの最小化
- パフォーマンス測定自体が性能に影響しないよう配慮
- 測定間隔の調整（高頻度測定 vs 低オーバーヘッド）
- デバッグモードでのみ有効化

## ブラウザ互換性
- Chrome DevTools APIの活用
- Safari、Firefoxでの代替手段
- モバイルブラウザでの測定制限

## 視覚的フィードバック
- パフォーマンス状態の直感的な表示
- 閾値超過時の警告表示
- ユーザビリティを損なわないUI設計

# パフォーマンス監視によるオーバーヘッド

## 測定機能による性能影響

パフォーマンス監視機能の導入により、本来のアプリケーション性能に以下の影響が生じる可能性がある：

### FPS測定によるフレームレート低下
- **requestAnimationFrame**の追加実行により1-3FPS程度の低下
- 大量要素描画時（1000+要素）では最大5%の性能低下
- 毎フレーム実行される計算処理の累積効果

### メモリ・処理時間測定のオーバーヘッド
- **performance.memory**API呼び出し（5秒間隔）：軽微
- **performance.now()**による時間測定：測定対象処理に対して1-2%の追加処理時間
- イベントキャプチャフェーズでの測定処理：全イベントに対する軽微な遅延

### DOM/SVG要素監視の影響
- **MutationObserver**によるDOM変更監視：要素追加・削除時の軽微な処理負荷
- 要素カウント処理：querySelector実行によるわずかな負荷

## オーバーヘッド最小化対策

### 1. 測定頻度の調整
```typescript
// 高精度 vs 低オーバーヘッドの選択
const precision = process.env.NODE_ENV === 'development' ? 'high' : 'low';
const skipRate = precision === 'high' ? 1 : 5; // 5フレームに1回測定
```

### 2. サンプリング測定
```typescript
// 確率的測定でオーバーヘッドを削減
if (Math.random() > 0.8) { // 20%の確率で測定
  measureEventPerformance(event);
}
```

### 3. アイドル時測定
```typescript
// ブラウザのアイドル時間を活用
requestIdleCallback(() => {
  updatePerformanceMetrics();
});
```

### 4. 条件付き無効化
```typescript
const config = {
  enabled: process.env.NODE_ENV === 'development' && window.location.search.includes('debug=true'),
  lightMode: true // 軽量測定モード
};
```

## 推奨運用方針

- **開発環境**: 詳細測定を有効化してパフォーマンス問題を早期発見
- **ステージング環境**: 軽量モードで基本的な監視のみ実施
- **本番環境**: 完全無効化またはサンプリング測定（1%程度）
- **性能検証時**: 測定機能を無効化した状態での性能測定も併せて実施

この監視オーバーヘッドを考慮した上で、開発効率とのバランスを取りながら適切な測定レベルを選択することが重要である。

# 実装詳細

## FPS測定実装 (Next.js)
```typescript
// hooks/usePerformanceMonitor.ts
import { useEffect, useRef, useCallback } from 'react';

interface FPSMetrics {
  fps: number;
  status: 'good' | 'warning' | 'error';
}

export const useFPSMonitor = (enabled: boolean = false) => {
  const fpsRef = useRef(0);
  const frameCountRef = useRef(0);
  const lastTimeRef = useRef(performance.now());
  const animationIdRef = useRef<number>();
  const displayCallbackRef = useRef<(metrics: FPSMetrics) => void>();

  const updateFPS = useCallback(() => {
    const now = performance.now();
    frameCountRef.current++;

    if (now - lastTimeRef.current >= 1000) {
      const fps = Math.round((frameCountRef.current * 1000) / (now - lastTimeRef.current));
      const status: FPSMetrics['status'] = fps >= 55 ? 'good' : fps >= 30 ? 'warning' : 'error';
      
      fpsRef.current = fps;
      
      // React stateを使わずコールバックで通知
      displayCallbackRef.current?.({ fps, status });
      
      frameCountRef.current = 0;
      lastTimeRef.current = now;
    }

    if (enabled) {
      animationIdRef.current = requestAnimationFrame(updateFPS);
    }
  }, [enabled]);

  useEffect(() => {
    if (!enabled) {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
      return;
    }

    animationIdRef.current = requestAnimationFrame(updateFPS);

    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
    };
  }, [enabled, updateFPS]);

  const registerDisplayCallback = useCallback((callback: (metrics: FPSMetrics) => void) => {
    displayCallbackRef.current = callback;
  }, []);

  return { 
    getCurrentFPS: () => fpsRef.current,
    registerDisplayCallback
  };
};
```

## メモリ監視実装 (Next.js)
```typescript
// hooks/useMemoryMonitor.ts
import { useEffect, useRef, useCallback } from 'react';

interface MemoryMetrics {
  used: number;
  total: number;
  limit: number;
  timestamp: number;
}

interface MemoryHistory extends MemoryMetrics {
  trend?: 'increasing' | 'stable' | 'decreasing';
}

export const useMemoryMonitor = (enabled: boolean = false, interval: number = 5000) => {
  const historyRef = useRef<MemoryHistory[]>([]);
  const intervalIdRef = useRef<NodeJS.Timeout>();
  const callbackRef = useRef<(data: MemoryHistory) => void>();

  const measure = useCallback(() => {
    if (typeof window === 'undefined' || !('performance' in window) || !performance.memory) {
      console.warn('performance.memory API not available');
      return;
    }

    const memory: MemoryMetrics = {
      timestamp: Date.now(),
      used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024), // MB
      total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
      limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
    };

    // 履歴に追加
    historyRef.current.push(memory);
    if (historyRef.current.length > 60) { // 5分間の履歴（5秒間隔）
      historyRef.current.shift();
    }

    // メモリリーク検出
    const leak = checkMemoryLeak();
    const trend = getTrend();
    
    const memoryWithTrend: MemoryHistory = { ...memory, trend };
    callbackRef.current?.(memoryWithTrend);

    if (leak) {
      console.warn('Potential memory leak detected:', leak, 'MB increase');
    }
  }, []);

  const checkMemoryLeak = useCallback(() => {
    if (historyRef.current.length < 6) return null;
    
    const recent = historyRef.current.slice(-6); // 直近30秒
    const trend = recent[recent.length - 1].used - recent[0].used;
    
    return trend > 50 ? trend : null;
  }, []);

  const getTrend = useCallback(() => {
    if (historyRef.current.length < 3) return 'stable';
    
    const recent = historyRef.current.slice(-3);
    const avgChange = (recent[2].used - recent[0].used) / 2;
    
    if (avgChange > 5) return 'increasing';
    if (avgChange < -5) return 'decreasing';
    return 'stable';
  }, []);

  useEffect(() => {
    if (!enabled) {
      if (intervalIdRef.current) {
        clearInterval(intervalIdRef.current);
      }
      return;
    }

    // 初回測定
    measure();
    
    // 定期測定
    intervalIdRef.current = setInterval(measure, interval);

    return () => {
      if (intervalIdRef.current) {
        clearInterval(intervalIdRef.current);
      }
    };
  }, [enabled, interval, measure]);

  const registerCallback = useCallback((callback: (data: MemoryHistory) => void) => {
    callbackRef.current = callback;
  }, []);

  return {
    getHistory: () => historyRef.current,
    getCurrentMemory: () => historyRef.current[historyRef.current.length - 1],
    registerCallback
  };
};
```

## 処理時間測定実装 (Next.js)
```typescript
// hooks/useTimingMonitor.ts
import { useRef, useCallback } from 'react';

type TimingCategory = 'rendering' | 'interaction' | 'taskOperation' | 'undoRedo';

interface TimingMetrics {
  category: TimingCategory;
  duration: number;
  timestamp: number;
}

interface TimingStats {
  avg: number;
  max: number;
  p95: number;
  count: number;
}

export const useTimingMonitor = (enabled: boolean = false) => {
  const measurementsRef = useRef<Record<TimingCategory, TimingMetrics[]>>({
    rendering: [],
    interaction: [],
    taskOperation: [],
    undoRedo: []
  });
  
  const callbackRef = useRef<(category: TimingCategory, stats: TimingStats) => void>();

  const startTimer = useCallback((category: TimingCategory) => {
    if (!enabled) return { end: () => {} };

    const startTime = performance.now();
    
    return {
      end: () => {
        const duration = performance.now() - startTime;
        const measurement: TimingMetrics = {
          category,
          duration,
          timestamp: Date.now()
        };

        // 測定データを保存
        measurementsRef.current[category].push(measurement);
        
        // 直近100件のみ保持
        if (measurementsRef.current[category].length > 100) {
          measurementsRef.current[category].shift();
        }

        // 統計計算
        const stats = calculateStats(category);
        callbackRef.current?.(category, stats);

        // 警告レベルのチェック
        if (duration > 16.67) { // 60FPS threshold
          console.warn(`Long running ${category}:`, duration.toFixed(2), 'ms');
        }

        return duration;
      }
    };
  }, [enabled]);

  const calculateStats = useCallback((category: TimingCategory): TimingStats => {
    const data = measurementsRef.current[category];
    if (data.length === 0) {
      return { avg: 0, max: 0, p95: 0, count: 0 };
    }

    const durations = data.map(item => item.duration);
    const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
    const max = Math.max(...durations);
    const sorted = [...durations].sort((a, b) => a - b);
    const p95 = sorted[Math.floor(sorted.length * 0.95)] || 0;

    return {
      avg: Number(avg.toFixed(2)),
      max: Number(max.toFixed(2)),
      p95: Number(p95.toFixed(2)),
      count: data.length
    };
  }, []);

  const getStats = useCallback((category: TimingCategory) => {
    return calculateStats(category);
  }, [calculateStats]);

  const getAllStats = useCallback(() => {
    const categories: TimingCategory[] = ['rendering', 'interaction', 'taskOperation', 'undoRedo'];
    return categories.reduce((acc, category) => {
      acc[category] = calculateStats(category);
      return acc;
    }, {} as Record<TimingCategory, TimingStats>);
  }, [calculateStats]);

  const registerCallback = useCallback((callback: (category: TimingCategory, stats: TimingStats) => void) => {
    callbackRef.current = callback;
  }, []);

  return {
    startTimer,
    getStats,
    getAllStats,
    registerCallback
  };
};

// 使用例: コンポーネント内での処理時間測定
export const useRenderingTimer = () => {
  const { startTimer } = useTimingMonitor(true);
  
  return useCallback((renderFunction: () => void) => {
    const timer = startTimer('rendering');
    renderFunction();
    timer.end();
  }, [startTimer]);
};
```

## DOM/SVG要素監視実装
```javascript
class ElementCounter {
  constructor() {
    this.counts = {
      aoaTasks: 0,
      annotations: { text: 0, shape: 0, image: 0 },
      totalDOM: 0,
      svgGroups: 0
    };
    this.history = [];
  }
  
  updateCounts() {
    // AOAタスク要素
    this.counts.aoaTasks = document.querySelectorAll('[data-task-id]').length;
    
    // アノテーション要素
    this.counts.annotations.text = document.querySelectorAll('[data-type="text"]').length;
    this.counts.annotations.shape = document.querySelectorAll('[data-type="shape"]').length;
    this.counts.annotations.image = document.querySelectorAll('[data-type="image"]').length;
    
    // 総DOM要素数
    this.counts.totalDOM = document.querySelectorAll('*').length;
    
    // SVGグループ数
    this.counts.svgGroups = document.querySelectorAll('svg g').length;
    
    // 履歴記録
    this.history.push({
      timestamp: Date.now(),
      ...JSON.parse(JSON.stringify(this.counts))
    });
    
    // 直近50件のみ保持
    if (this.history.length > 50) {
      this.history.shift();
    }
    
    this.updateDisplay();
    this.checkThresholds();
  }
  
  checkThresholds() {
    const total = this.counts.aoaTasks + 
                  this.counts.annotations.text + 
                  this.counts.annotations.shape + 
                  this.counts.annotations.image;
    
    if (total > 1000) {
      console.warn('Element count approaching limit:', total);
    }
  }
}
```

## イベント処理性能測定実装
```javascript
class EventPerformanceMonitor {
  constructor() {
    this.eventTimes = {
      mouseEvents: [],
      keyboardEvents: [],
      touchEvents: []
    };
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // マウスイベント監視
    ['click', 'mousemove', 'mouseup', 'mousedown'].forEach(eventType => {
      document.addEventListener(eventType, (e) => {
        this.measureEventHandling(e, 'mouseEvents');
      }, { capture: true });
    });
    
    // キーボードイベント監視
    ['keydown', 'keyup'].forEach(eventType => {
      document.addEventListener(eventType, (e) => {
        this.measureEventHandling(e, 'keyboardEvents');
      }, { capture: true });
    });
  }
  
  measureEventHandling(event, category) {
    const startTime = performance.now();
    
    // 次のフレームで処理完了時間を測定
    requestAnimationFrame(() => {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.eventTimes[category].push({
        type: event.type,
        duration,
        timestamp: Date.now()
      });
      
      // 直近100件のみ保持
      if (this.eventTimes[category].length > 100) {
        this.eventTimes[category].shift();
      }
      
      // 遅延警告（100ms超過）
      if (duration > 100) {
        console.warn(`Slow ${event.type} handling:`, duration.toFixed(2), 'ms');
      }
    });
  }
  
  getStats(category) {
    const data = this.eventTimes[category];
    if (data.length === 0) return null;
    
    const durations = data.map(item => item.duration);
    const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
    const max = Math.max(...durations);
    
    return {
      count: data.length,
      avgDuration: avg.toFixed(2),
      maxDuration: max.toFixed(2)
    };
  }
}
```

## Undo/Redo性能測定実装
```javascript
class UndoRedoMonitor {
  constructor() {
    this.metrics = {
      undoTimes: [],
      redoTimes: [],
      historySize: 0,
      operationCount: 0
    };
  }
  
  measureUndoOperation(undoFunction) {
    const startTime = performance.now();
    
    return new Promise((resolve) => {
      const result = undoFunction();
      
      // 非同期処理完了後に時間測定
      Promise.resolve(result).then(() => {
        const duration = performance.now() - startTime;
        this.metrics.undoTimes.push(duration);
        this.metrics.operationCount++;
        
        // 直近50件のみ保持
        if (this.metrics.undoTimes.length > 50) {
          this.metrics.undoTimes.shift();
        }
        
        // 遅延警告（500ms超過）
        if (duration > 500) {
          console.warn('Slow undo operation:', duration.toFixed(2), 'ms');
        }
        
        this.updateDisplay();
        resolve(result);
      });
    });
  }
  
  measureRedoOperation(redoFunction) {
    const startTime = performance.now();
    
    return new Promise((resolve) => {
      const result = redoFunction();
      
      Promise.resolve(result).then(() => {
        const duration = performance.now() - startTime;
        this.metrics.redoTimes.push(duration);
        this.metrics.operationCount++;
        
        if (this.metrics.redoTimes.length > 50) {
          this.metrics.redoTimes.shift();
        }
        
        if (duration > 500) {
          console.warn('Slow redo operation:', duration.toFixed(2), 'ms');
        }
        
        this.updateDisplay();
        resolve(result);
      });
    });
  }
  
  updateHistorySize(historyData) {
    // 履歴データのメモリサイズを推定
    this.metrics.historySize = JSON.stringify(historyData).length;
    this.updateDisplay();
  }
  
  getStats() {
    const undoAvg = this.metrics.undoTimes.length > 0 ? 
      (this.metrics.undoTimes.reduce((a, b) => a + b, 0) / this.metrics.undoTimes.length).toFixed(2) : 0;
    const redoAvg = this.metrics.redoTimes.length > 0 ? 
      (this.metrics.redoTimes.reduce((a, b) => a + b, 0) / this.metrics.redoTimes.length).toFixed(2) : 0;
    
    return {
      undoAverage: undoAvg,
      redoAverage: redoAvg,
      historySize: Math.round(this.metrics.historySize / 1024), // KB
      totalOperations: this.metrics.operationCount
    };
  }
}
```

## 統合実装 (Next.js)
```typescript
// hooks/usePerformanceMonitor.ts - 統合フック
import { useState, useEffect, useCallback } from 'react';
import { useFPSMonitor } from './useFPSMonitor';
import { useMemoryMonitor } from './useMemoryMonitor';
import { useTimingMonitor } from './useTimingMonitor';

interface PerformanceConfig {
  enabled: boolean;
  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  updateInterval?: number;
}

interface PerformanceMetrics {
  fps: { fps: number; status: 'good' | 'warning' | 'error' };
  memory: { used: number; total: number; limit: number; trend?: string };
  timing: Record<string, { avg: number; max: number; p95: number; count: number }>;
}

export const usePerformanceMonitor = (config: PerformanceConfig) => {
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
    fps: { fps: 0, status: 'good' },
    memory: { used: 0, total: 0, limit: 0 },
    timing: {}
  });

  const fps = useFPSMonitor(config.enabled);
  const memory = useMemoryMonitor(config.enabled, config.updateInterval);
  const timing = useTimingMonitor(config.enabled);

  // FPS更新コールバック
  fps.registerDisplayCallback(useCallback((fpsData) => {
    setMetrics(prev => ({ ...prev, fps: fpsData }));
  }, []));

  // メモリ更新コールバック
  memory.registerCallback(useCallback((memoryData) => {
    setMetrics(prev => ({ 
      ...prev, 
      memory: { 
        used: memoryData.used, 
        total: memoryData.total, 
        limit: memoryData.limit,
        trend: memoryData.trend 
      }
    }));
  }, []));

  // タイミング更新コールバック
  timing.registerCallback(useCallback((category, stats) => {
    setMetrics(prev => ({
      ...prev,
      timing: { ...prev.timing, [category]: stats }
    }));
  }, []));

  const exportData = useCallback((format: 'json' | 'csv' = 'json') => {
    const data = {
      timestamp: new Date().toISOString(),
      fps: metrics.fps,
      memory: memory.getHistory(),
      timing: timing.getAllStats()
    };

    if (format === 'json') {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `performance-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }
  }, [metrics, memory, timing]);

  const measureOperation = useCallback(async <T>(
    operation: () => Promise<T> | T,
    category: 'rendering' | 'interaction' | 'taskOperation' | 'undoRedo' = 'interaction'
  ): Promise<T> => {
    const timer = timing.startTimer(category);
    try {
      const result = await operation();
      return result;
    } finally {
      timer.end();
    }
  }, [timing]);

  return {
    metrics,
    exportData,
    measureOperation,
    startTimer: timing.startTimer,
    isEnabled: config.enabled
  };
};

// components/DebugDashboard.tsx - 表示コンポーネント
import React from 'react';

interface DebugDashboardProps {
  metrics: PerformanceMetrics;
  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  onClose?: () => void;
  onExport?: () => void;
}

export const DebugDashboard: React.FC<DebugDashboardProps> = ({
  metrics,
  position = 'top-right',
  onClose,
  onExport
}) => {
  const positionClasses = {
    'top-left': 'top-4 left-4',
    'top-right': 'top-4 right-4',
    'bottom-left': 'bottom-4 left-4',
    'bottom-right': 'bottom-4 right-4'
  };

  return (
    <div className={`fixed ${positionClasses[position]} bg-black/90 text-white p-4 rounded-lg z-50 font-mono text-xs min-w-[200px]`}>
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-sm font-bold">Performance Monitor</h3>
        <button onClick={onClose} className="text-gray-400 hover:text-white">×</button>
      </div>
      
      {/* FPS */}
      <div className="flex items-center gap-2 mb-1">
        <div className={`w-2 h-2 rounded-full ${
          metrics.fps.status === 'good' ? 'bg-green-500' :
          metrics.fps.status === 'warning' ? 'bg-yellow-500' : 'bg-red-500'
        }`} />
        <span>FPS: {metrics.fps.fps}</span>
      </div>
      
      {/* Memory */}
      <div className="mb-1">
        <span>Memory: {metrics.memory.used}MB / {metrics.memory.total}MB</span>
        {metrics.memory.trend && (
          <span className={`ml-2 text-xs ${
            metrics.memory.trend === 'increasing' ? 'text-red-400' :
            metrics.memory.trend === 'decreasing' ? 'text-green-400' : 'text-gray-400'
          }`}>
            {metrics.memory.trend}
          </span>
        )}
      </div>
      
      {/* Timing */}
      <div className="mb-2">
        {Object.entries(metrics.timing).map(([category, stats]) => (
          <div key={category} className="text-xs">
            {category}: {stats.avg}ms avg, {stats.max}ms max
          </div>
        ))}
      </div>
      
      <div className="flex gap-2">
        <button 
          onClick={onExport}
          className="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded"
        >
          Export
        </button>
      </div>
    </div>
  );
};
```

