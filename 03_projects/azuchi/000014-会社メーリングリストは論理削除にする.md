---
type: note
moc: "[[🏷️ADR]]"
tags:
- '#ai/ref'
---
> [!info] 必要なセクションを選択して使用してください！

# 📜 文脈・背景

メーリングリスト削除時の日報テーブル参照方法について：

現在の案の評価：Cascade SetNull
メリット:
- 実装がシンプル
- Prismaの標準機能で対応可能
- データの整合性が保たれる
デメリット・問題点:
- **情報の永続的な喪失**: どのメーリングリストが使用されていたかの履歴が消える
- **監査の困難**: 過去の送信でどのリストが使われたかトレースできない
- **参照エラーの可能性**: アプリケーション側で null チェックが必要
- **ユーザー混乱**: 日報詳細画面で「不明なメーリングリスト」と表示される



# 🎨 対応案


### 案1: ソフトデリート（推奨）

メーリングリストテーブルに `deletedAt`(or `isArchived`) フィールドを追加し、物理削除の代わりに論理削除を使用：

prisma

```prisma
model MailingLists {
  id          String    @id
  name        String
  description String?
  deletedAt   DateTime? // 追加
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model WorkDailyReportMailingList {
  id                String   @id
  workDailyReportId String
  mailingListId     String
  createdAt         DateTime @default(now())
  
  // CASCADE のまま維持
  workDailyReport WorkDailyReports @relation(fields: [workDailyReportId], references: [id], onDelete: Cascade)
  mailingList     MailingLists     @relation(fields: [mailingListId], references: [id], onDelete: Cascade)
}
```

**実装例:**

typescript

```typescript
// メーリングリスト取得（削除済みを除外）
const activeMailingLists = await prisma.mailingLists.findMany({
  where: {
    deletedAt: null // アクティブのみ
  }
});

// 日報のメーリングリスト取得（削除済みも含む）
const reportWithMailingLists = await prisma.workDailyReports.findUnique({
  where: { id: reportId },
  include: {
    WorkDailyReportMailingList: {
      include: {
        mailingList: true // 削除済みでも取得される
      }
    }
  }
});

// UI表示での処理
reportWithMailingLists.WorkDailyReportMailingList.map(item => ({
  id: item.mailingListId,
  name: item.mailingList.deletedAt 
    ? `${item.mailingList.name} (削除済み)` 
    : item.mailingList.name,
  isDeleted: !!item.mailingList.deletedAt
}));
```

### 案2: 名前の非正規化（スナップショット保存）

日報作成時にメーリングリスト名を保存：

prisma

```prisma
model WorkDailyReportMailingList {
  id                String   @id
  workDailyReportId String
  mailingListId     String?  // nullable に変更
  mailingListName   String   // 追加：作成時点の名前を保存
  createdAt         DateTime @default(now())
  
  workDailyReport WorkDailyReports @relation(fields: [workDailyReportId], references: [id], onDelete: Cascade)
  mailingList     MailingLists?    @relation(fields: [mailingListId], references: [id], onDelete: SetNull)
}
```

**実装例:**

typescript

```typescript
// 日報作成時
const mailingList = await prisma.mailingLists.findUnique({
  where: { id: mailingListId }
});

await prisma.workDailyReportMailingList.create({
  data: {
    workDailyReportId: reportId,
    mailingListId: mailingList.id,
    mailingListName: mailingList.name // スナップショット保存
  }
});

// 表示時
const reportMailingLists = await prisma.workDailyReportMailingList.findMany({
  where: { workDailyReportId: reportId },
  include: { mailingList: true }
});

reportMailingLists.map(item => ({
  name: item.mailingList?.name || `${item.mailingListName} (削除済み)`,
  isDeleted: !item.mailingList
}));
```

### 案3: 履歴テーブルの作成

削除されたメーリングリストの情報を別テーブルで保持：

prisma

```prisma
model MailingListHistory {
  id            String   @id
  originalId    String   // 元のメーリングリストID
  name          String
  description   String?
  deletedAt     DateTime @default(now())
  deletedBy     String?  // 削除したユーザー
}

model WorkDailyReportMailingList {
  id                String   @id
  workDailyReportId String
  mailingListId     String?  // nullable
  createdAt         DateTime @default(now())
  
  workDailyReport WorkDailyReports @relation(fields: [workDailyReportId], references: [id], onDelete: Cascade)
  mailingList     MailingLists?    @relation(fields: [mailingListId], references: [id], onDelete: SetNull)
}
```

### 案4: 削除制限（参照チェック）

使用中のメーリングリストは削除を禁止：

typescript

```typescript
// 削除前チェック
async function deleteMailingList(mailingListId: string) {
  const usageCount = await prisma.workDailyReportMailingList.count({
    where: { mailingListId }
  });
  
  if (usageCount > 0) {
    throw new Error(`このメーリングリストは${usageCount}件の日報で使用されているため削除できません`);
  }
  
  await prisma.mailingLists.delete({
    where: { id: mailingListId }
  });
}
```

### 各案の比較表

| 項目      | SetNull (現在案) | ソフトデリート | 名前非正規化 | 履歴テーブル | 削除制限 |
| ------- | ------------- | ------- | ------ | ------ | ---- |
| 実装コスト   | 低             | 低       | 中      | 高      | 低    |
| 情報保持    | ×             | ○       | ○      | ○      | ○    |
| 監査対応    | ×             | ○       | ○      | ○      | ○    |
| データ整合性  | ○             | ○       | △      | ○      | ○    |
| パフォーマンス | ○             | ○       | ○      | △      | ○    |
| ユーザビリティ | ×             | ○       | ○      | ○      | △    |

# 🚀 決定

案１：ソフトデリート(論理削除)を採用する。
- 削除されたメーリングリストの名前が保持される
- 監査要件に対応できる
- ユーザーは削除済みリストを識別できる
- 実装コストが適切な範囲に収まる
- 将来的な要件変更にも柔軟に対応可能
# 🪞 結果・影響

【決定】による結果・影響、ないし成果  (outcomes)  やアウトプット・フォローアップを記述します。

肯定的・中立的・否定的、いずれの観点からも列挙すべきです。  このセクションに「プラスの結果」「マイナスの結果」といった小項目を予め用意しておくと、記述しやすくなるかもしれません。

繰り返しになりますが、アーキテクチャ決定は、連鎖的に影響を及ぼすことがあります。  この ADR での【決定】が、後続の ADR にも影響するのならば、それを記述しておくことができます。

【結果・影響】を記述するタイミングは、いくつか考えられます。 【決定】を下したのと同じタイミングで、これらを予想して記述しても構いません。  また、例えば１ヶ月後といった一定期間後に、レビューを行い追記することもできます。  その場合は  [After-Action Review](https://en.wikipedia.org/wiki/After-action_review)  や、トレードオフ分析などが考えられます。

# 🍜 今後の検討事項

【決定】を踏まえて、今後検討すべき事項を記載します。


