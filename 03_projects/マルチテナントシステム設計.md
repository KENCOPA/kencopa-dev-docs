---
type: note
tags:
- '#ai/ref'
---
# 重要事項

> [!important] **本ドキュメントの位置づけ:**
> - 本設計書は実装の**方針と基本的な考え方**を示すものであり、コードレベルの詳細な設計仕様書ではない
> - ソフトウェアの開発進捗、要件変更、技術的な制約等に応じて**適宜変更される**ものとする
> - 実装時には、本設計書を参考にしつつ、具体的な技術選択や詳細設計は開発チームの判断で行う

# 概要

本ドキュメントは、AWS Cognitoを認証基盤としたマルチテナントSaaSアプリケーションの設計方針について記述する。

## 設計方針

- **認証と認可の分離**: AWS Cognitoが認証を担当し、アプリケーションが認可を管理
- **シンプルなデータモデル**: CognitoのSUBをユーザーIDとして直接使用
- **拡張性の確保**: 将来的な機能追加を考慮した設計

## システムアーキテクチャ

```
┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│   Client    │────▶│ AWS Cognito  │────▶│     API     │
│ (Frontend)  │     │  User Pool   │     │  Gateway    │
└─────────────┘     └──────────────┘     └─────────────┘
      │                     │                     │
      │  1. Login          │  2. ID Token       │ 3. Validate
      └────────────────────┴─────────────────────┘
                                                 │
                                                 ▼
                                          ┌─────────────┐
                                          │  Backend    │
                                          │   (Hono)    │
                                          └─────────────┘
```

# ドメインモデル

## エンティティ構成

```
User (Cognito SUB as ID)
    │
    └── Membership ────── Tenant
            │               │
            └── Role ───────┘
```

## User（ユーザー集約）

**概要**: AWS CognitoのSUBを直接UserのIDとして使用し、プロフィール情報を管理する。

**実装方針**:
```typescript
class User extends Aggregation<UserId, typeof User.KEY> {
  private _id: UserId;  // CognitoのSUBを直接使用
  private _familyName: FamilyName;
  private _givenName: GivenName;
  private _displayName: DisplayName;
}
```

**代替案**:
- **アプリケーション独自のUserID生成**: Cognitoとは別にUUIDを生成し、マッピングテーブルで管理
  - 却下理由: IDマッピングの管理が必要、ユーザー削除時の整合性確保が複雑
- **CognitoProfileキャッシpュテーブル**: Cognitoの情報をローカルDBにキャッシュ
  - 却下理由: データの二重管理による不整合のリスク、同期処理の複雑性

**選択理由**:
- **シンプルさ**: 余計なマッピングテーブルが不要
- **データ整合性**: Cognitoユーザーとアプリケーションユーザーが1:1で対応
- **トランザクション管理**: 中間テーブルがないため、削除や更新が単純
- **パフォーマンス**: ID変換のオーバーヘッドがない

## Tenant（テナント集約）

**概要**: 組織（テナント）の基本情報を管理し、マルチテナント分離を実現する。

**実装方針**:
```typescript
class Tenant extends Aggregation<TenantId, typeof Tenant.KEY> {
  private _id: TenantId;
  private _name: TenantName;
  private _subdomain: Subdomain;
  private _status: TenantStatus;
}
```

**代替案**:
- **階層テナント構造**: 親子関係を持つテナント構造
  - 却下理由: 初期要件では過剰な複雑さ、管理コストが高い
- **テナントグループ**: 複数テナントをグループ化する機能
  - 却下理由: 現在のユースケースでは不要、将来的な拡張として保留

**選択理由**:
- **シンプルな構造**: フラットなテナント構造で管理が容易
- **独立性**: 各テナントが完全に独立した組織として機能
- **拡張性**: 将来的な階層化も可能な基盤設計
- **YAGNI原則**: 現在必要な機能に集中し、過剰な設計を避ける

## Role（ロール集約）

**概要**: テナント内での役割定義をシンプルに管理する。

**実装方針**:
```typescript
class Role extends Aggregation<RoleId, typeof Role.KEY> {
  private _id: RoleId;
  private _tenantId: TenantId;
  private _name: RoleName;  // "Admin", "Member" など
}
```

**代替案**:
- **詳細権限管理**: 各ロールに詳細な権限リストを持たせる
  - 却下理由: 初期要件では過剰な複雑さ、実装コストが高い
- **システムロール**: 全テナント共通のシステムロールを定義
  - 却下理由: テナント独立性を保つため、ロールはテナントスコープで管理
- **ロール優先順位**: 複数ロール間の優先順位管理
  - 却下理由: 単一ロール制では不要な機能

**選択理由**:
- **シンプルさ**: 現在の要件には十分で、理解・保守が容易
- **YAGNI原則**: 複雑な権限管理は将来的な拡張として保留
- **拡張性**: 必要に応じて後から機能追加が可能
- **テナント独立性**: 各テナントが独自のロールを定義可能

## Membership（メンバーシップ集約）

**概要**: ユーザーとテナントの関係、招待フロー、権限管理を一元的に管理する。

**実装方針**:
```typescript
class Membership extends Aggregation<MembershipId, typeof Membership.KEY> {
  private _membershipId: MembershipId
  private _userId: UserId;
  private _tenantId: TenantId;
  private _roleId: RoleId;         // 単一ロール
  private _status: MembershipStatus;
  private _invitedBy: MembershipId;
  private _invitedAt: DateTime;
  private _joinedAt: DateTime;
}
```

ポイント:
- **Membershipテーブルには、招待者の情報を記録する**
  - 概念的な統一性
    - **単一のライフサイクル**: 招待から参加まで、一つのエンティティとして自然に表現できる
    - **状態遷移の明確化**: `invited → active` という単純な状態遷移で、メンバーシップの全段階を表現
    - **ドメイン知識の保持**: 「このメンバーシップがどのように始まったか」という重要な情報が永続的に保持される
  - 実装のシンプルさ
    - **トランザクション不要**: 招待承認が単一レコードの更新で完結
    - **クエリの簡潔性**: JOINなしで必要な情報を取得可能
    - **エラーハンドリングの単純化**: 一つのテーブルのみを扱うため、エラーケースが限定的
  - ビジネス価値
    - **監査ログとしての価値**: セキュリティインシデント時に「誰がこのユーザーを招待したか」を即座に特定可能
    - **分析の容易性**: 招待成功率、招待者別のコンバージョン率などのメトリクスを簡単に算出
    - **将来の拡張性**: 招待経由以外の参加方法（直接追加、SSO連携など）も同じスキーマで対応可能
    
### テナント内リソースにおけるmembershipIdの利用
**基本原則**:
  - テナント内の全リソースは MembershipID を外部キーとして使用する
  - UserIDの直接参照は 禁止 とする
  - 「アイテムをユーザーではなく、ユーザーのメンバーシップに割り当てる」原則を厳守

**外部キー制約**:

  - ON DELETE SET NULL: メンバーシップ削除時は自動的にNULLに設定
  - ON DELETE CASCADE: リソース削除が必要な場合のみ使用
  - 履歴保持のため、必要に応じてスナップショット情報を併用

**セキュリティ上の利点**:

  - テナント脱退時の自動データクリーンアップ
  - 組織境界の厳密な維持
  - GDPR等プライバシー法規への対応容易性
  - 不正アクセスのリスク軽減

**運用上の利点**:

  - 招待段階でのリソース割り当て可能
  - 課金計算の簡素化（MembershipIDカウント）
  - 組織別分析の効率化
  - テナント切り替え時の明確なコンテキスト管理

**例外事項**:

  - UserIDを使用する場合: グローバルレベルの操作のみ（ユーザープロフィール、組織一覧取得等）
  - 履歴保持: 必要に応じてemail、nameのスナップショットを併用



### 名前の由来

**ビジネス概念の適切な表現**
- **組織への所属**: 「メンバーシップ」は「組織の一員である状態」を自然に表現
- **権限と責任**: メンバーとしての権限と責任を包含する概念
- **継続的な関係**: 一時的な参加ではなく、継続的な所属関係を示す

**状態管理の自然性**
- **招待段階**: 「メンバーシップを提案された」→ 自然な表現
- **承認段階**: 「メンバーシップが承認された」→ 自然な表現  
- **アクティブ段階**: 「アクティブなメンバーシップを持つ」→ 自然な表現
- **停止段階**: 「メンバーシップが停止された」→ 自然な表現

**ドメイン専門家とのコミュニケーション**
- **理解しやすさ**: ビジネス担当者が直感的に理解できる
- **議論の効率性**: 「メンバーシップの管理」という概念で要件定義が進めやすい
- **ユーザー向け説明**: ユーザーインターフェースでも「メンバーシップ」として表示可能

**拡張性**
- **メンバーシップレベル**: 将来的に「プレミアムメンバーシップ」等の概念拡張が自然
- **メンバーシップ期間**: 期間限定メンバーシップなどの概念も含められる
- **メンバーシップ特典**: ロール以外の付加的な権利・特典も管理可能

**他システムとの一貫性**
- **SaaS業界標準**: 多くのSaaSアプリケーションで「Membership」概念が使用される
- **オンライン文献**: ドキュメントや技術記事での説明が豊富
- **開発者の理解**: 新しい開発者がシステムに参加した際の理解コストが低い

**実世界との対応関係**:
```
現実世界                    システム内
─────────────────────    ─────────────────────
会社の従業員になる         → Membershipを作成
部署異動（役職変更）       → Membershipのrole変更  
退職                      → Membershipを非アクティブ化
契約社員として招待         → Membership（invited状態）
正社員として承認           → Membership（active状態）
```

**代替案との比較**
- 「UserTenant」という名前
	- **却下理由**: 
	  - 技術的で機械的な印象を与える
	  - ビジネス概念を表現していない
	  - 単なる関連テーブルのような印象
- 「UserRole」という名前  
	- **却下理由**:
	  - ロールが主概念のように見える
	  - テナントとの関係性が不明確
	  - 招待フローなどの状態管理の概念が含まれない
- 「Participation」という名前
	- **却下理由**:
	  - 一般的すぎて何への参加かが不明確
	  - ビジネスドメインでの使用頻度が低い
	  - 権限の概念が含まれない

- 「TenantUser」という名前
	- **却下理由**:
	  - 「User」が後ろに来ることで、Userの一種のような印象
	  - テナント側からの視点に偏っている


### 代替案と詳細な却下理由

#### Invitationを別テーブルに分離する案

MembershipとInvitationを別々のテーブルで管理し、招待が承認されたらInvitationレコードからMembershipレコードを作成する設計。

```typescript
// 別テーブル案
class Invitation {
  private _id: InvitationId;
  private _email: Email;
  private _tenantId: TenantId;
  private _roleId: RoleId;
  private _invitedBy: UserId;
  private _invitedAt: DateTime;
  private _token: InvitationToken;
  private _expiresAt: DateTime;
  private _status: InvitationStatus; // pending, accepted, expired
}

class Membership {
  private _userId: UserId;
  private _tenantId: TenantId;
  private _roleId: RoleId;
  private _joinedAt: DateTime;
  // invitationの情報は含まない
}
```

**却下理由（詳細）**:

- データの一貫性と複雑性
  - **状態管理の二重化**: InvitationとMembershipで同じユーザー・テナントの組み合わせを重複管理することになり、整合性確保が複雑
  - **トランザクション境界の拡大**: 招待承認時にInvitationの更新とMembershipの作成を同一トランザクションで行う必要があり、エラーハンドリングが複雑化
  - **外部キー参照の喪失**: Membershipから「誰に招待されたか」を参照できなくなり、別途Invitationテーブルを結合する必要が生じる
- ビジネスロジックの不自然さ
```typescript
// 別テーブルの場合の招待承認処理（複雑）
async function acceptInvitation(token: InvitationToken): Promise<void> {
  // 1. Invitationを検索
  const invitation = await invitationRepository.findByToken(token);
  
  // 2. 有効性チェック
  if (invitation.isExpired() || invitation.status !== 'pending') {
    throw new InvalidOperationError();
  }
  
  // 3. トランザクション開始
  await db.transaction(async (trx) => {
    // 4. Invitationを更新
    invitation.accept();
    await invitationRepository.save(invitation, trx);
    
    // 5. 新規Membershipを作成
    const membership = new Membership({
      userId: currentUserId,
      tenantId: invitation.tenantId,
      roleId: invitation.roleId,
      joinedAt: new DateTime()
      // invitedByの情報が失われる
    });
    await membershipRepository.save(membership, trx);
  });
}

// 統合テーブルの場合（シンプル）
async function acceptInvitation(membershipId: MembershipId): Promise<void> {
  const membership = await membershipRepository.findById(membershipId);
  
  if (membership.status !== MembershipStatus.Invited) {
    throw new InvalidOperationError();
  }
  
  membership.accept(); // statusをactiveに、joinedAtを設定
  await membershipRepository.save(membership);
}
```

- クエリパフォーマンスと運用面
  - **JOIN処理の増加**: 「このユーザーを誰が招待したか」を取得するために、毎回JOINが必要
  - **データ整合性の監視**: InvitationとMembershipの不整合を定期的にチェックする運用が必要
  - **ストレージの無駄**: 承認済みInvitationレコードの保持により、ストレージを二重に消費

- 実装の複雑さの具体例
```sql
-- 別テーブルの場合：招待者情報を含むメンバー一覧取得（複雑）
SELECT 
  m.user_id,
  m.role_id,
  m.joined_at,
  i.invited_by,
  i.invited_at
FROM memberships m
LEFT JOIN invitations i 
  ON i.email = (SELECT email FROM users WHERE id = m.user_id)
  AND i.tenant_id = m.tenant_id
  AND i.status = 'accepted'
WHERE m.tenant_id = ?;

-- 統合テーブルの場合（シンプル）
SELECT 
  user_id,
  role_id,
  joined_at,
  invited_by,
  invited_at
FROM memberships
WHERE tenant_id = ?;
```

# 業務フロー

## 1. ユーザー登録・初回ログイン

**フロー概要**:
(略: 別の設計文章で記載するかもしれない)

## 2. テナント作成・管理

**フロー概要**:
1. ユーザーが新規テナント作成
2. 作成者が自動的にAdminロールでメンバーシップ作成
3. テナント設定・管理

**実装例**:
```typescript
// テナント作成フロー
async function createTenant(
  creatorUserId: UserId,
  tenantName: string,
  subdomain: string
): Promise<{ tenant: Tenant; membership: Membership }> {
  
  // 1. テナント作成
  const tenant = new Tenant({
    name: new TenantName(tenantName),
    subdomain: new Subdomain(subdomain),
    status: TenantStatus.Active
  });
  
  await tenantRepository.save(tenant);
  
  // 2. デフォルトロール作成
  const adminRole = new Role({
    tenantId: tenant.id,
    name: new RoleName('Admin')
  });
  
  await roleRepository.save(adminRole);
  
  // 3. 作成者をAdminとして登録
  const membership = new Membership({
    userId: creatorUserId,
    tenantId: tenant.id,
    roleId: adminRole.id,
    status: MembershipStatus.Active,
    joinedAt: new DateTime()
  });
  
  await membershipRepository.save(membership);
  
  return { tenant, membership };
}
```

## 3. メンバー招待・参加

**フロー概要**:
1. Admin権限ユーザーがメンバーを招待
2. 被招待者に招待メール送信
3. 被招待者が招待承認
4. アクティブなメンバーシップに変更

**実装例**:
```typescript
// 1. 招待の作成
async function inviteUserToTenant(
  inviterUserId: UserId,
  inviteeEmail: Email,
  tenantId: TenantId,
  roleId: RoleId
): Promise<void> {
  // 招待者の権限確認
  const inviterMembership = await membershipRepository.find(inviterUserId, tenantId);
  if (!inviterMembership.hasPermission(Permission.InviteMember)) {
    throw new ForbiddenError('招待権限がありません');
  }

  // メンバーシップを「invited」ステータスで作成
  const membership = new Membership({
    userId: inviteeUserId,
    tenantId,
    roleId,
    status: MembershipStatus.Invited,
    invitedBy: inviterUserId,
    invitedAt: new DateTime()
  });
  
  await membershipRepository.save(membership);
  await emailService.sendInvitation(inviteeEmail, tenantName);
}

// 2. 招待の承認
async function acceptInvitation(membershipId: MembershipId): Promise<void> {
  const membership = await membershipRepository.findById(membershipId);
  
  if (membership.status !== MembershipStatus.Invited) {
    throw new InvalidOperationError('既に処理済みの招待です');
  }
  
  membership.accept(); // status を active に変更、joinedAt を設定
  await membershipRepository.save(membership);
  
  // 招待者への通知
  if (membership.invitedBy) {
    await notificationService.notifyInvitationAccepted(
      membership.invitedBy,
      membership.userId,
      membership.tenantId
    );
  }
}
```

## 4. テナント切り替え・認証認可

**フロー概要**:
1. ユーザーが作業するテナントを選択
2. X-Tenant-IDヘッダーでテナントコンテキストを指定
3. 各APIリクエストで権限チェック

**実装例**:
```typescript
// テナント切り替え
async function switchTenant(userId: UserId, tenantId: TenantId): Promise<TenantContext> {
  const membership = await membershipRepository.findByUserAndTenant(userId, tenantId);
  
  if (!membership || !membership.isActive()) {
    throw new UnauthorizedError('Access denied to this tenant');
  }
  
  const role = await roleRepository.findById(membership.roleId);
  
  return new TenantContext({
    userId,
    tenantId,
    membershipId: membership.id,
    roleId: membership.roleId,
    permissions: role.permissions
  });
}

// 認証・認可ミドルウェア
export class TenantAuthMiddleware {
  async handle(c: Context, next: Function) {
    // 1. Cognitoトークンの検証
    const cognitoUser = await this.verifyCognitoToken(c.req.header('Authorization'));
    
    // 2. テナントコンテキストの設定
    const tenantId = c.req.header('X-Tenant-ID');
    if (tenantId) {
      const membership = await this.validateMembership(cognitoUser.sub, tenantId);
      c.set('authContext', { 
        userId: cognitoUser.sub, 
        tenantId, 
        membershipId: membership.id, 
        roleId: membership.roleId 
      });
    }
    
    await next();
  }
}
```

### 代替案と詳細な却下理由

#### セッショントークン方式

テナント選択時にアプリケーション独自のセッショントークンを発行し、以降のAPIリクエストで使用する方式。

```typescript
// テナント切り替え時にセッショントークンを発行
const sessionToken = await generateSessionToken({
  userId,
  tenantId,
  membershipId,
  roleId,
  expiresIn: '24h'
});

// 以降のAPIリクエスト
const headers = {
  'Authorization': `Bearer ${sessionToken}`  // Cognitoトークンの代わり
};
```

**却下理由（詳細）**:
- **独自トークン管理の負担**: JWTの署名・検証、リフレッシュトークンの管理、トークンの無効化などの機能を自分で実装する必要
  - (そこまで大変ではないが、必要が出てきたら実装する)
- **AWS Cognito Authorizer不使用**: API Gatewayのネイティブな認証機能が使えず、カスタムオーサライザーを作成する必要o
- **セキュリティリスク**: トークン管理のバグがセキュリティホールにつながるリスク
- **スケーラビリティ**: ユーザー数が増えた際のトークン管理の負荷

#### リクエストボディでテナント指定

各APIリクエストのボディにtenantIdを含めてテナントコンテキストを指定する方式。

```typescript
// 各APIリクエストのボディにテナントIDを含める
const requestBody = {
  tenantId: selectedTenantId,
  productName: 'New Product',
  price: 1000
};
```

**却下理由（詳細）**:
- **デバッグの困難さ**: ネットワークタブやログでテナントコンテキストが見えない
- **GETリクエストでの不便**: GETメソッドではボディがないため、クエリパラメータで送る必要があり、一貫性がない
- **ミドルウェアでの処理が複雑**: リクエストボディをパースしてtenantIdを抽出する処理が必要
- **キャッシュが難しい**: キーにテナントIDを含めることができない

### URLパスでテナントID指定

URLパスにテナントIDを含める方式。

```typescript
// URLパスでテナントを指定
GET /api/v1/tenants/tenant-123/products
POST /api/v1/tenants/tenant-123/users
PUT /api/v1/tenants/tenant-123/settings
```

(※認可ルートがUserとMembershipで異なる場合は、URLパスで`tenant`を採用する可能性もある)

**却下理由（詳細）**:
- **URLの複雑化**: 全てのAPIエンドポイントが `/tenants/{tenantId}/` プレフィックスを持つことになり、URLが長くなる
- **ルーティング設定の複雑性**: テナントスコープのAPIとグローバルAPI（ユーザー作成、テナント一覧など）で異なるパス構造
- **フロントエンドの負担**: テナント切り替え時に全てのAPIエンドポイントURLを再構築する必要
- **OpenAPIスキーマの煩雑さ**: 同じ機能のAPIがテナントスコープとグローバルスコープで重複定義される

## 5. テナント削除・データ管理

**フロー概要**:
1. Admin権限でテナント削除実行
2. 関連するMemberships、Rolesが自動削除（CASCADE）
3. Userレコードは保持

**実装例**:
```typescript
// テナント削除の実装
async function deleteTenant(
  tenantId: TenantId, 
  adminUserId: UserId
): Promise<void> {
  // 1. Admin権限の確認
  await validateAdminPermission(adminUserId, tenantId);
  
  // 2. Tenant削除（Membershipsは自動削除）
  await tenantRepository.delete(tenantId);
}
```

# データベース設計

## テーブル定義

```sql
-- ユーザープロフィール
CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,  -- CognitoのSUBをそのまま使用
    family_name VARCHAR(100) NOT NULL,
    given_name VARCHAR(100) NOT NULL,
    display_name VARCHAR(200),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- テナント
CREATE TABLE tenants (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    subdomain VARCHAR(63) UNIQUE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ロール
CREATE TABLE roles (
    id VARCHAR(36) PRIMARY KEY,
    tenant_id VARCHAR(36) NOT NULL,
    name VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    UNIQUE (tenant_id, name)
);

-- メンバーシップ
CREATE TABLE memberships (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    tenant_id VARCHAR(36) NOT NULL,
    role_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'active',
    joined_at TIMESTAMP,
    invited_at TIMESTAMP,
    invited_by VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE RESTRICT,
    FOREIGN KEY (invited_by) REFERENCES users(id) ON DELETE SET NULL,
    UNIQUE (user_id, tenant_id)
);
```

## データ削除戦略

**外部キー制約の設計**:

- **users → memberships**: CASCADE（ユーザー削除時、関連メンバーシップも削除）
- **tenants → memberships**: CASCADE（テナント削除時、関連メンバーシップも削除）
- **roles → memberships**: RESTRICT（ロール削除時、使用中であれば削除拒否）
- **users → memberships (invited_by)**: SET NULL（招待者削除時、招待履歴は保持）

point: 
- **データ整合性**: 参照整合性制約により不正なデータ状態を防止
- **運用のシンプルさ**: Admin操作によるテナント削除が簡潔
- **ユーザー体験**: 所属テナントがなくなっても、ユーザーは新しいテナントを作成可能
- **柔軟性**: ユーザーアカウントは保持され、他テナントからの再招待が容易


### 代替案と詳細な却下理由

#### 手動削除運用
テナント削除時に、関連するメンバーシップ、ロールなどを管理者が手動で削除する運用。

**却下理由（詳細）**:
- **操作ミスのリスク**: 関連データの削除漏れ、間違ったデータの削除、削除順序の間違いなど
- **運用コスト**: テナント削除のたびに複数のSQLコマンドを正しい順序で実行する必要
- **データ整合性リスク**: 削除処理中にエラーが発生した場合、不整合な状態が残る可能性
- **スケーラビリティ**: テナント数が増えると運用負荷が線形的に増加

#### 論理削除管理
物理削除を行わず、deleted_atフィールドやis_deletedフラグで削除状態を管理する方式。

**却下理由（詳細）**:
- **データ量の継続的増加**: 削除されたデータも永続的に保存され、ストレージコストが増加
- **クエリパフォーマンスの悪化**: 全てのクエリに `WHERE deleted_at IS NULL` 条件が必要で、インデックス効率が低下
- **論理的複雑さ**: 「削除されたテナント」のメンバーはどう扱うべきかなど、状態管理が複雑
- **ユーザー体験の悪化**: 削除済みテナントに関連するデータが残り、ユーザーに混乱を与える可能性
- **GDPR等への対応困難**: 「完全なデータ削除」が要求された場合の対応が複雑

#### 全てRESTRICT制約
すべての外部キー制約でRESTRICTを使用し、参照されているレコードの削除を禁止する方式。

**却下理由（詳細）**:
- **テナント削除の実質的不可能**: メンバーが存在する限りテナントを削除できないため、事実上テナント削除機能が機能しない
- **運用手順の複雑化**: テナント削除のために、まず全メンバーを個別に削除する必要
- **緊急時の対応困難**: セキュリティインシデント時に迅速なテナント停止ができない
- **ビジネスコンテキストとの不一致**: 「組織を解散したい」というビジネスニーズに技術的制約で対応できない


# まとめ

本設計方針により、以下を実現する：

1. **シンプルで保守しやすい**: CognitoのSUBを直接使用し、余計な複雑性を排除
2. **柔軟な権限管理**: マルチテナント・マルチロールに対応
3. **高いセキュリティ**: AWS Cognitoの堅牢な認証基盤を活用
4. **優れた拡張性**: 将来的な要件変更に対応可能

この設計方針は、スタートアップから大規模エンタープライズまで、幅広い規模のSaaSアプリケーションに適用可能である。

# 注意事項とドキュメント管理

## 実装時の注意点

#### 実装時の判断指針
- **設計書の位置づけ**: 本設計書は「方針」であり「仕様書」ではない。実装時の技術的制約や性能要件で適切に調整すべき
- **优先度の考慮**: 設計書で、同等に表現されている機能でも、ビジネス価値やリスクで実装順序を決定する
- **技術スタックとの適合**: チームの技術スタックや既存システムとの連携を考慮した実装選択

#### 段階的実装の指針
- **MVPのスコープ**: 最初は「ユーザー・テナント・基本的なメンバーシップ」だけで十分
- **拡張の順序**: 招待機能 → 権限管理の精緻化 → メトリクス・監査機能の順で拡張を推奨
- **後方互換性**: 将来の拡張を阻害しないよう、インターフェース設計やデータベーススキーマを設計

# References
- https://www.flightcontrol.dev/blog/ultimate-guide-to-multi-tenant-saas-data-modeling