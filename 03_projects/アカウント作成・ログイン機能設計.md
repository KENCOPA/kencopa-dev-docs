---
type: note
moc: "[[🏷️基本設計書]]"
tags:
- '#ai/ref'
---
本ドキュメントは基本設計・詳細設計書の体裁に従わず、簡易的に設計を記載します。


# References

v0 mockup
-  https://v0-sm-mauve.vercel.app/login

Epic Documents:
- ログイン(認証)機能: [[ユーザー認証機能]]

# 前提条件

UI:
- 画面右半分に画像を表示させるが、現状はなくても良い（時間があれば実装する）
- スケジュールがタイトなので、UIに凝らなくても良い（後から変更できるため）

アカウント作成機能: 
- 会社情報の設定画面は現状実装しなくて良い
- システムフローについてはazuchiを踏襲

ユーザー招待後のテナント選択画面:
- 招待中ステータスのテナントについては、よしなにUIを表示する（他Productなど参照する）


# アカウント作成機能
## 機能要件

### メールアドレスとパスワードの入力
- ユーザーはメールアドレスとパスワードを入力してアカウント作成を開始できる
- パスワードは以下の要件を満たす必要がある：
  - 最小8文字
  - 大文字・小文字・数字・特殊文字を含む（Cognito標準ポリシーに準拠）
- 入力値のバリデーションを行い、エラーメッセージを表示する

### 基本情報の入力
- ユーザーは以下の基本情報を入力する：
  - 氏名（姓・名）
  - 会社名（任意）
  - 電話番号（任意）

### メール認証（SES経由）
- Amazon SESを使用して認証コード付きメールを送信する
- ユーザーは受信した6桁の認証コードを入力する
- 認証コードの有効期限は15分とする
- 認証コードの再送信機能を提供する
- 認証完了後、Cognitoユーザープールにユーザーを登録する

### テナント設定のスキップ
- テナント作成フローは現状スキップ可能とする
- スキップした場合はデフォルトテナントに紐付ける、または後から設定可能とする

### バックエンドへのユーザー情報登録
- Cognito登録成功後、バックエンドサーバーのuserテーブルにユーザー情報を登録する
- 登録情報：
  - cognito_user_id（Cognito Sub）
  - email
  - 氏名
  - 会社名
  - 電話番号
  - 作成日時

### 完了画面の表示
- アカウント作成完了メッセージを表示する
- ログイン画面またはダッシュボードへの遷移リンクを提供する

### エラーハンドリング
- Cognito APIエラー（メールアドレス重複、認証コード不正など）の適切な表示
- バックエンドAPIエラーの適切な表示
- ネットワークエラーの適切な表示

## 画面レイアウト

### 全体構成
- 2カラムレイアウト（デスクトップ）
  - 左側: メインコンテンツエリア（フォーム入力）
  - 右側: AIアシスタント＆ブランディングエリア
- モバイルでは1カラム表示（メインコンテンツのみ）

### メインコンテンツエリア（左側）
- プログレスバー表示
  - 現在のステップ数 / 全体ステップ数を視覚的に表示
  - 各ステップのタイトル表示
- フォームコンテンツ
  - ステップごとにアニメーション遷移
  - 最大幅: 448px（max-w-md）
  - 中央配置
- ナビゲーションボタン
  - 「次へ」「戻る」「スキップ」ボタン
  - ローディング状態の表示

### AIアシスタント＆ブランディングエリア（右側）
- 背景: ダークグラデーション（slate-900 to slate-800）
- エフェクト: ぼかしのある円形グラデーション
- コンテンツ構成:
  - ヘッダー: Kencopaロゴ、キャッチコピー
  - メイン: AIアシスタントメッセージ表示
  - フッター: コピーライト表示

### ステップ構成
1. **ようこそ画面**
   - サービス説明
   - 開始ボタン
2. **基本情報入力**
   - メールアドレス
   - パスワード（確認用含む）
   - 氏名（姓・名）
   - 会社名（任意）
   - 電話番号（任意）
3. **メール認証**
   - 認証コード入力フィールド（6桁）
   - 再送信リンク
   - カウントダウンタイマー
4. **完了画面**
   - 完了メッセージ
   - ログイン画面への遷移ボタン
   
  (※) テナント作成画面は現状不要のためスキップ

## システムワークフロー

```
[ユーザー] → [Frontend] → [AWS Cognito] → [Backend API] → [DB]

1. 基本情報入力フェーズ
   - ユーザーがメールアドレス、パスワード、氏名等を入力
   - Frontend: 入力値のバリデーション

2. Cognito仮登録フェーズ
   - Frontend → Cognito: SignUp API呼び出し（メールアドレスとパスワードのみ）
   - Cognito → SES: 認証コード付きメール送信
   - Cognito → Frontend: SignUp成功レスポンス（UserConfirmed: false）

3. メール認証フェーズ
   - ユーザーがメールから認証コードを取得
   - Frontend → Cognito: ConfirmSignUp API呼び出し（認証コード送信）
   - Cognito → Frontend: 認証完了レスポンス（UserConfirmed: true）

4. サインインフェーズ（重要）
   - **注意**: AWS Amplify SDKを使用する場合、ConfirmSignUpは自動的にユーザーをサインインさせない
   - Frontend → Cognito: SignIn API呼び出し（メールアドレスとパスワードで明示的にサインイン）
   - Cognito → Frontend: IDトークン、アクセストークン、リフレッシュトークン発行
   - これにより、認証セッションが確立され、以降のAPI呼び出しでAuthorizationヘッダーが利用可能になる

5. バックエンド登録フェーズ
   - Frontend → Backend: POST /api/users（ユーザー情報 + Authorizationヘッダー）
   - Backend: IDトークン検証（Authorizationヘッダーから取得）
   - Backend → DB: userテーブルにINSERT
   - Backend → Frontend: 登録完了レスポンス

6. 完了フェーズ
   - Frontend: 完了画面表示
   - ユーザーをテナント選択画面またはログイン画面に遷移
```

### 状態管理とセキュリティ方針

**フォームデータの保持方針**:
- **SessionStorage/LocalStorageは使用しない**
  - セキュリティリスク（XSS攻撃でパスワードなどの機密情報が漏洩する可能性）を排除
  - バグの発生源となるストレージ同期問題を回避
  - シンプルで予測可能な動作を保証

- **メモリ上のReact Stateのみで管理**
  - フォームデータ（メール、パスワード、氏名など）はReactのstateで保持
  - ページリロード時は自動的にStep1から開始
  - 機密情報がブラウザストレージに一切保存されない

**データ検証による自動リダイレクト**:
```typescript
// Step3で必要なデータがない場合、自動的にStep1に戻す
useEffect(() => {
  if (currentStep === 3) {
    if (!formData.email || !formData.password || !formData.firstName || !formData.lastName) {
      setCurrentStep(1);
    }
  }
}, [currentStep, formData]);
```

**利点**:
- ✅ **セキュリティ**: パスワードやその他の機密情報が永続化されない
- ✅ **バグ削減**: ストレージ同期の問題が発生しない
- ✅ **シンプル**: コードが簡潔で理解しやすい
- ✅ **予測可能**: リロード時は常にStep1から開始、データ不足時も自動的にStep1に戻る

**トレードオフ**:
- ⚠️ リロード時に入力データが失われる
  - ただし、アカウント作成フローは通常数分で完了するため、実用上の問題は少ない
  - セキュリティの向上がUX上の小さな不便さを上回る

### AWS Amplify SDK使用時の注意事項

**ConfirmSignUp後の自動サインインについて**:
- AWS Cognitoのデフォルト設定では、`ConfirmSignUp`の呼び出しだけではユーザーをサインイン状態にしない
- AWS Amplify SDKを使用する場合、サインアップと確認が完了した後に**手動で`signIn`を呼び出す必要がある**
- 自動サインインする高レベルなAPIは提供されていないため、以下の順序で実装する必要がある：
  1. `Auth.signUp()`: ユーザー作成
  2. `Auth.confirmSignUp()`: メール認証コード確認
  3. **`Auth.signIn()`**: 明示的なサインイン（メールアドレスとパスワードを使用）
  4. `Auth.currentAuthenticatedUser()`: サインイン済みユーザー情報の取得

**実装例**:
```typescript
// Step 1: サインアップ
await Auth.signUp({
  username: email,
  password: password
});

// Step 2: メール認証
await Auth.confirmSignUp(email, verificationCode);

// Step 3: 明示的にサインイン（重要！）
await Auth.signIn(email, password);

// Step 4: 認証済みユーザー情報取得
const user = await Auth.currentAuthenticatedUser();

// これでAccessTokenが利用可能になり、BackendへのAPI呼び出しが可能
```

**Lambda Trigger（Post Confirmation）を使用する代替案**:
- Cognito User PoolのLambda Triggerで「Post Confirmation」を設定すると、ユーザー確認後に自動的にバックエンド登録処理を実行できる
- ただし、この場合もクライアント側でサインインプロセスを実行する必要がある
- 本実装では、フロントエンド主導のフローを採用しているため、Lambda Triggerは使用しない

### API連携詳細

**Cognito API:**
- `SignUp`: ユーザー仮登録（メールアドレスとパスワードのみ）
- `ConfirmSignUp`: メール認証コード確認
- `SignIn`: 認証（トークン取得）

**Backend API:**
- `POST /api/v1/users`: ユーザー情報登録
  - Request Header: `Authorization: Bearer {AccessToken}`
  - Request Body:
    ```json
    {
      "email": "user@example.com",
      "firstName": "太郎",
      "lastName": "山田",
    }
    ```
  - Response:
    ```json
    {
      "userId": "uuid",
      "cognitoUserId": "cognito-sub",
      "email": "user@example.com"
    }
    ```

---

# ログイン機能
## 機能要件

### メールアドレスとパスワード認証
- ユーザーはメールアドレスとパスワードを入力してログインする
- 入力値のバリデーションを行い、エラーメッセージを表示する
- パスワードの表示/非表示トグル機能を提供する

### ログイン状態の保持
- 「ログイン状態を保持する」チェックボックスを提供
- チェックされている場合、トークンをローカルストレージに保存
- チェックされていない場合、セッションストレージに保存

### パスワードリセット機能
- 「パスワードを忘れた場合」リンクを表示
- パスワードリセットフローへ遷移

### アカウント作成画面への遷移
- 「アカウント作成」リンクを表示
- サインアップ画面へ遷移

### トークン管理
- Cognitoから発行されたIDトークン、アクセストークン、リフレッシュトークンを管理
- トークンの有効期限管理
- リフレッシュトークンによる自動トークン更新

### テナント選択画面への遷移
- ログイン成功後、ユーザーが所属するテナントを取得
- 複数テナントに所属している場合、テナント選択画面へ遷移
- 単一テナントの場合、直接ダッシュボードへ遷移

### エラーハンドリング
- 認証エラー（メールアドレスまたはパスワード不正）の適切な表示
- アカウント未確認エラーの表示（メール認証未完了）
- ネットワークエラーの適切な表示
- アカウントロック状態の表示

## 画面レイアウト

### 全体構成
- 2カラムレイアウト（デスクトップ）
  - 左側: ログインフォーム
  - 右側: ブランディング画像とメッセージ
- モバイルでは1カラム表示（ログインフォームのみ）

### ログインフォームエリア（左側）
- ロゴ表示
- ページタイトル「ログイン」
- 説明文「アカウントにログインしてください」
- 入力フォーム:
  - メールアドレス入力フィールド（アイコン付き）
  - パスワード入力フィールド（アイコン＋表示/非表示トグル）
  - 「ログイン状態を保持する」チェックボックス
  - 「パスワードを忘れた場合」リンク
- ログインボタン（ローディング状態表示）
- アカウント作成リンク
- 最大幅: 350px
- 中央配置

### ブランディングエリア（右側）
- 建設現場の背景画像
- グラデーションオーバーレイ（下部を暗く）
- テキストコンテンツ:
  - メインメッセージ「建設業界のDXを推進」
  - サブメッセージ「AIが支援する次世代プロジェクト管理」
- アニメーション演出

## システムワークフロー

```
[ユーザー] → [Frontend] → [AWS Cognito] → [Backend API] → [DB]

1. 認証フェーズ
   - ユーザーがメールアドレスとパスワードを入力
   - Frontend: 入力値のバリデーション
   - Frontend → Cognito: SignIn API呼び出し
   - Cognito: 認証情報の検証
   - Cognito → Frontend: IDトークン、アクセストークン、リフレッシュトークン発行

2. トークン保存フェーズ
   - Frontend: 「ログイン状態を保持する」のチェック状態を確認
   - チェックあり: ローカルストレージに保存
   - チェックなし: セッションストレージに保存

3. テナント取得フェーズ
   - Frontend → Backend: GET /api/users/me/tenants（IDトークン付き）
   - Backend: IDトークン検証
   - Backend → DB: ユーザーのテナント情報を取得
   - Backend → Frontend: テナント一覧レスポンス

4. 画面遷移フェーズ
   - Frontend: テナント数を確認
   - 単一テナント: ダッシュボードへ直接遷移
   - 複数テナント: テナント選択画面へ遷移
   - テナントなし: エラー表示（通常発生しない）
```

### API連携詳細

**Cognito API:**
- `SignIn`: 認証（トークン取得）
  - Parameters:
    ```json
    {
      "AuthFlow": "USER_PASSWORD_AUTH",
      "ClientId": "cognito-client-id",
      "AuthParameters": {
        "USERNAME": "user@example.com",
        "PASSWORD": "password"
      }
    }
    ```
  - Response:
    ```json
    {
      "AuthenticationResult": {
        "AccessToken": "access-token",
        "IdToken": "id-token",
        "RefreshToken": "refresh-token",
        "ExpiresIn": 3600
      }
    }
    ```

**Backend API:**
- `GET /api/users/me/tenants`: ユーザーのテナント情報取得
  - Request Header: `Authorization: Bearer {IDToken}`
  - Response:
    ```json
    {
      "tenants": [
        {
          "tenantId": "uuid",
          "tenantName": "テナント名",
          "role": "admin"
        }
      ]
    }
    ```

---

# 補足: Cognito認証認可とデータベース設計

## Cognitoの基本概念

### Cognitoが管理する情報
AWS Cognitoユーザープールは以下の情報を管理する：

- **Sub（Subject）**: Cognitoが自動生成するユーザーの一意識別子（UUID形式）
  - 例: `1234567-abcd-1234-efgh-1234567890ab`
  - 変更不可の永続的なID
  - このSubをバックエンドのユーザーIDとして使用する

- **標準属性**:
  - `email`: メールアドレス（ユーザー名としても使用）
  - `email_verified`: メール認証済みフラグ
  - `phone_number`: 電話番号（オプション）

- **カスタム属性**:
  - 必要に応じて追加可能（例: `custom:company_name`）

- **注意**: 氏名（`given_name`, `family_name`）はCognitoには保存せず、バックエンドDBのみで管理する

### IDトークンとアクセストークン
- **IDトークン**: ユーザー情報を含むJWT
  - Sub、email、email_verifiedなどのクレームを含む
  - バックエンドAPIへの認証に使用
  - 有効期限: 1時間（デフォルト）

- **アクセストークン**: リソースアクセス用のトークン
  - Cognito APIの呼び出しに使用
  - 有効期限: 1時間（デフォルト）

- **リフレッシュトークン**: トークン更新用
  - 有効期限: 30日（デフォルト、設定可能）

## データベーススキーマ設計

### usersテーブル
```sql
CREATE TABLE users (
  -- プライマリキー（CognitoのSubを使用）
  user_id UUID PRIMARY KEY,

  -- 基本情報（バックエンドで管理）
  email VARCHAR(255) NOT NULL UNIQUE,
  first_name VARCHAR(100),
  last_name VARCHAR(100),
  --...

);
```

## Cognito認証フロー詳細

### アカウント作成時のデータフロー

```
1. ユーザー入力
   - email: user@example.com
   - password: SecurePass123!
   - firstName: 太郎
   - lastName: 山田

2. Frontend → Cognito SignUp
   Cognitoに送信されるデータ（メールアドレスとパスワードのみ）:
   {
     "Username": "user@example.com",
     "Password": "SecurePass123!",
     "UserAttributes": [
       {"Name": "email", "Value": "user@example.com"}
     ]
   }

3. Cognito処理
   - ユーザープールに仮登録
   - Sub（UUID）を自動生成
   - SES経由で認証コード送信

4. ユーザーがメール認証コード入力

5. Frontend → Cognito ConfirmSignUp
   - メール認証完了
   - ユーザーステータス: CONFIRMED

6. Frontend → Cognito SignIn（明示的なサインイン）
   - メールアドレスとパスワードでサインイン
   - レスポンス（IDトークン）の内容:
   {
     "sub": "1234567-abcd-1234-efgh-1234567890ab",
     "email": "user@example.com",
     "email_verified": true,
     "cognito:username": "user@example.com",
     "exp": 1234567890
   }

7. Frontend → Backend POST /api/users
   リクエストヘッダー:
   - Authorization: Bearer {AccessToken}

   リクエストボディ:
   {
     "email": "user@example.com",
     "firstName": "太郎",
     "lastName": "山田"
   }

8. Backend処理
   a. AccessTokenの検証
      - JWT署名の検証
      - 有効期限の確認
      - Issuerの確認（CognitoユーザープールURL）

   b. トークンからSubを抽出
      - sub = "1234567-abcd-1234-efgh-1234567890ab"

   c. DBにユーザー登録
      INSERT INTO users (user_id, email, first_name, last_name)
      VALUES (
        '1234567-abcd-1234-efgh-1234567890ab',  -- CognitoのSub
        'user@example.com',
        '太郎',
        '山田'
      );

   d. デフォルトテナントへの紐付け（オプション）
      INSERT INTO tenant_members (tenant_id, user_id, role, status)
      VALUES ('{default-tenant-id}', '{user_id}', 'member', 'active');

9. Backend → Frontend
   レスポンス:
   {
     "userId": "1234567-abcd-1234-efgh-1234567890ab",
     "email": "user@example.com"
   }
```

### ログイン時のデータフロー

```
1. Frontend → Cognito SignIn
   {
     "Username": "user@example.com",
     "Password": "SecurePass123!"
   }

2. Cognito処理
   - 認証情報の検証
   - トークン発行

3. Cognito → Frontend
   {
     "AccessToken": "xxx",
     "IdToken": "yyy",  # Sub, email, email_verified等を含む
     "RefreshToken": "zzz"
   }

4. Frontend処理
   - トークンをローカルストレージ/セッションストレージに保存
   - IDトークンをデコードしてユーザー情報を取得

5. Frontend → Backend GET /api/users/me/tenants
   Authorization: Bearer {IDToken}

6. Backend処理
   a. IDトークン検証
   b. Subをトークンから抽出
   c. DB問い合わせ
      SELECT t.tenant_id, t.tenant_name, tm.role
      FROM tenant_members tm
      JOIN tenants t ON tm.tenant_id = t.tenant_id
      WHERE tm.user_id = '{sub}'
      AND tm.status = 'active';

7. Backend → Frontend
   テナント一覧を返却
```

## バックエンドでのトークン検証実装

### IDトークン検証の流れ
```typescript
import jwt from 'jsonwebtoken';
import jwksClient from 'jwks-rsa';

// JWKS（JSON Web Key Set）クライアントの初期化
const client = jwksClient({
  jwksUri: `https://cognito-idp.{region}.amazonaws.com/{userPoolId}/.well-known/jwks.json`
});

// 公開鍵の取得
function getKey(header, callback) {
  client.getSigningKey(header.kid, (err, key) => {
    const signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

// トークン検証ミドルウェア
async function verifyToken(req, res, next) {
  const token = req.headers.authorization?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    // JWT検証
    const decoded = await new Promise((resolve, reject) => {
      jwt.verify(token, getKey, {
        issuer: `https://cognito-idp.{region}.amazonaws.com/{userPoolId}`,
        algorithms: ['RS256']
      }, (err, decoded) => {
        if (err) reject(err);
        else resolve(decoded);
      });
    });

    // Subをリクエストに追加
    req.userId = decoded.sub;
    req.userEmail = decoded.email;

    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}
```

## 重要なポイント

### 1. SubをユーザーIDとして使用する理由
- Cognitoが自動生成する一意の識別子
- メールアドレス変更後も変わらない永続的なID
- UUID形式で衝突の心配がない
- Cognitoとバックエンドでユーザーを一意に紐付けられる

### 2. Cognitoとバックエンドの役割分担
- **Cognito**: 認証（Authentication）のみ
  - ユーザー名/パスワードの検証
  - トークンの発行と管理
  - メール認証、MFA等の認証機能

- **Backend DB**: 認可（Authorization）とビジネスデータ
  - テナントへの所属情報
  - ロールベースのアクセス制御
  - ユーザーの詳細情報（氏名、会社名など）
  - ビジネスロジックに必要なデータ

### 3. データの管理方針
- **Cognito**: 認証に必要な最小限の情報（Sub, email, email_verified）
- **Backend DB**: 氏名を含むすべてのビジネスデータ
- 氏名の取得は`GET /api/v1/users/me`などのAPIで行う

### 4. セキュリティ考慮事項
- IDトークンは必ず検証すること（署名、有効期限、Issuer）
- トークンをHTTPSで送信すること
- リフレッシュトークンは安全に保管すること
- Cognitoのパスワードポリシーを適切に設定すること
