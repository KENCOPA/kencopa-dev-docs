# システム設計: 工種・細別ベクトル検索による意味的類似性検出システム

これまでの会話を踏まえ、kunai-core-backend、kunai-ai、kunai-core-frontendの3つのシステムを連携させた、工種・細別の意味的類似性検出システムの全体設計を抽象的に説明します。<cite />

## システム全体アーキテクチャ

```mermaid
graph TB
    subgraph "1. ユーザー入力層 (kunai-core-frontend)"
        A[工種・細別入力フォーム]
        B[類似性チェックボタン]
    end
    
    subgraph "2. データ管理層 (kunai-core-backend)"
        C[工種・細別作成API]
        D[UseCase層]
        E[PostgreSQLデータベース]
        F[イベント発行]
    end
    
    subgraph "3. イベント配信層 (AWS EventBridge)"
        G[イベントバス]
        H[イベントルール]
    end
    
    subgraph "4. AI処理層 (kunai-ai)"
        I[イベントハンドラー]
        J[ベクトル化UseCase]
        K[ベクトルストア]
        L[類似性検索API]
    end
    
    A -->|1. 工種名入力| B
    B -->|2. 類似性チェック要求| L
    L -->|3. ベクトル検索| K
    K -->|4. 類似工種リスト| B
    B -->|5. 確認後作成| C
    C -->|6. UseCase実行| D
    D -->|7. DB保存| E
    D -->|8. イベント発行| F
    F -->|9. イベント送信| G
    G -->|10. ルールマッチ| H
    H -->|11. Lambda/ECS起動| I
    I -->|12. ベクトル化実行| J
    J -->|13. インデックス保存| K
```

## 1. ユーザー入力フロー (kunai-core-frontend)

### 1.1 入力フォームの構成

ユーザーが工種・細別を追加する際の入力フローは以下の通りです:<cite />

```mermaid
sequenceDiagram
    participant User as ユーザー
    participant Form as 入力フォーム
    participant SimilarityCheck as 類似性チェック
    participant CreateAPI as 作成API
    
    User->>Form: 1. 大分類を選択
    User->>Form: 2. 工種名を入力
    Form->>SimilarityCheck: 3. 類似性チェック要求
    SimilarityCheck->>Form: 4. 類似工種リスト表示
    
    alt 類似工種が存在
        Form->>User: 5a. 警告表示
        User->>Form: 6a. 既存を使用 or 新規作成
    else 類似工種なし
        User->>Form: 5b. 作成続行
    end
    
    Form->>CreateAPI: 7. 作成リクエスト
    CreateAPI->>Form: 8. 作成完了
```

**主要コンポーネント**:
- `WorkTypeCreateModal`: 工種作成フォーム [13-cite-0](#13-cite-0) 
- `WorkUnitCreateModal`: 細別作成フォーム [13-cite-1](#13-cite-1) 

### 1.2 入力データの構造

```typescript
// 工種作成時の入力データ
{
  majorCategoryId: string,  // 大分類ID
  name: string,             // 工種名
  description?: string      // 説明(任意)
}

// 細別作成時の入力データ
{
  workTypeId: string,       // 工種ID
  name: string,             // 細別名
  description?: string      // 説明(任意)
}
```

## 2. データ管理フロー (kunai-core-backend)

### 2.1 データ階層構造  
  
kunai-core-backendでは4層のデータ階層が存在します:<cite />  
  
```mermaid  
graph TD  
    A[Tenant<br/>テナント] --> B[WorkTypeMaster<br/>工種体系マスター]  
    B --> C[MajorCategory<br/>大分類]  
    C --> D[TenantWorkType<br/>工種]  
    D --> E[TenantWorkUnit<br/>細別]  
      
    style A fill:#e1f5fe  
    style B fill:#b3e5fc  
    style C fill:#81d4fa  
    style D fill:#4fc3f7  
    style E fill:#29b6f6  
```
[13-cite-2](#13-cite-2)   
  
### 2.2 作成処理フロー

```mermaid
sequenceDiagram
    participant API as REST API
    participant UseCase as UseCase層
    participant Repo as Repository
    participant DB as PostgreSQL
    participant Event as EventPublisher
    
    API->>UseCase: 1. 作成コマンド
    UseCase->>Repo: 2. 重複チェック
    Repo->>DB: 3. 名前検索
    DB->>Repo: 4. 検索結果
    
    alt 重複あり
        Repo->>UseCase: 5a. 409 Conflict
        UseCase->>API: 6a. エラー返却
    else 重複なし
        UseCase->>Repo: 5b. エンティティ保存
        Repo->>DB: 6b. INSERT
        UseCase->>Event: 7. イベント発行
        Event->>API: 8. 成功返却
    end
```

**主要UseCase**:
- `CreateTenantWorkTypeUseCase`: 工種作成 [13-cite-3](#13-cite-3) 
- `CreateTenantWorkUnitUseCase`: 細別作成 [13-cite-4](#13-cite-4) 

### 2.3 イベント発行設計

```typescript
// イベントペイロード構造
interface WorkTypeCreatedEvent {
  type: 'TenantWorkTypeCreated',
  payload: {
    tenantId: string,
    workTypeId: string,
    majorCategoryId: string,
    name: string,
    description: string | null,
    timestamp: Date
  }
}
```

**発行タイミング**:
- 工種・細別の作成時
- 工種・細別の更新時
- 工種・細別のアーカイブ/アクティベート時

## 3. イベント配信層 (AWS EventBridge)

### 3.1 イベントフロー

```mermaid
graph LR
    A[kunai-core-backend] -->|イベント発行| B[EventBridge Bus]
    B -->|ルールマッチ| C[EventBridge Rule]
    C -->|Lambda起動| D[kunai-ai Handler]
    C -->|ECS起動| E[kunai-ai Task]
    
    style B fill:#ff9800
    style C fill:#ff9800
```

### 3.2 イベントルール設計

```json
{
  "source": ["kunai.core-backend"],
  "detail-type": [
    "TenantWorkTypeCreated",
    "TenantWorkTypeUpdated",
    "TenantWorkTypeArchived",
    "TenantWorkUnitCreated",
    "TenantWorkUnitUpdated",
    "TenantWorkUnitArchived"
  ]
}
```

## 4. AI処理フロー (kunai-ai)

### 4.1 ベクトル化処理

```mermaid
sequenceDiagram
    participant EB as EventBridge
    participant Handler as EventHandler
    participant UseCase as VectorizeUseCase
    participant Embeddings as OpenAI Embeddings
    participant VectorStore as ベクトルストア
    
    EB->>Handler: 1. イベント受信
    Handler->>UseCase: 2. ベクトル化要求
    UseCase->>Embeddings: 3. テキスト→ベクトル変換
    Embeddings->>UseCase: 4. ベクトル返却
    UseCase->>VectorStore: 5. メタデータ付き保存
    VectorStore->>Handler: 6. 保存完了
```

**ベクトルデータ構造**:
```python
{
  "id": "work-type-id",
  "vector": [0.1, 0.2, ...],  # 埋め込みベクトル
  "metadata": {
    "tenant_id": "tenant-xxx",
    "major_category_id": "major-category-yyy",
    "name": "工種名",
    "description": "説明",
    "type": "work_type"  # or "work_unit"
  }
}
```

### 4.2 類似性検索処理

```mermaid
sequenceDiagram
    participant Frontend as フロントエンド
    participant API as 類似性検索API
    participant Embeddings as OpenAI Embeddings
    participant VectorStore as ベクトルストア
    
    Frontend->>API: 1. 検索要求(name, tenantId, majorCategoryId)
    API->>Embeddings: 2. 入力テキスト→ベクトル変換
    Embeddings->>API: 3. クエリベクトル
    API->>VectorStore: 4. メタデータフィルタ付き検索
    VectorStore->>API: 5. 類似ベクトルリスト
    API->>Frontend: 6. 類似工種リスト(similarity >= threshold)
```

**検索リクエスト**:
```python
{
  "tenant_id": "xxx",
  "major_category_id": "yyy",  # スコープ絞り込み
  "name": "掘削工事",
  "threshold": 0.8  # 類似度閾値
}
```

**検索レスポンス**:
```python
{
  "similar_items": [
    {
      "id": "existing-id",
      "name": "掘削",
      "similarity": 0.85
    }
  ]
}
```

## 5. データ同期戦略

### 5.1 リアルタイム同期 (イベント駆動)

```mermaid
graph TB
    A[工種作成] --> B[DB保存]
    B --> C[イベント発行]
    C --> D[EventBridge]
    D --> E[kunai-ai起動]
    E --> F[ベクトル化]
    F --> G[ベクトルストア保存]
    
    style C fill:#4caf50
    style D fill:#4caf50
    style E fill:#4caf50
```

**メリット**:
- リアルタイム性: 即座にベクトル検索可能
- データ整合性: 常に最新状態を維持
- ユーザー体験: 類似性チェックが即座に機能

### 5.2 初期同期 (バッチ処理)

既存データのベクトル化には、バッチ処理を実装:<cite />

```mermaid
graph LR
    A[バッチ起動] --> B[全工種取得]
    B --> C[ベクトル化]
    C --> D[インデックス登録]
    D --> E[同期完了]
```

## 6. エラーハンドリング設計

### 6.1 リトライ戦略

```mermaid
graph TD
    A[イベント受信] --> B{処理成功?}
    B -->|成功| C[完了]
    B -->|一時エラー| D[リトライキュー]
    B -->|永続エラー| E[DLQ]
    D --> F[指数バックオフ]
    F --> A
    E --> G[アラート通知]
```

### 6.2 データ整合性チェック

```python
# 定期的な同期状態監視
async def check_sync_status(tenant_id: str) -> bool:
    db_count = await get_work_type_count_from_db(tenant_id)
    vector_count = await get_vector_count(tenant_id)
    return db_count == vector_count
```

## 7. スケーラビリティ考慮事項

### 7.1 テナント分離

- ベクトル検索時に`tenant_id`でフィルタリング<cite />
- 他テナントのデータが検索結果に含まれない保証

### 7.2 大分類スコープ

- `major_category_id`でさらに絞り込み<cite />
- 検索精度向上と処理速度改善

### 7.3 負荷分散

- EventBridgeによる非同期処理
- Lambda/ECS Fargateの自動スケーリング

## まとめ

このシステムは以下の3つの主要フローで構成されます:

1. **入力フロー**: ユーザーが工種・細別を入力 → 類似性チェック → 確認後作成
2. **同期フロー**: データ作成 → イベント発行 → ベクトル化 → インデックス保存
3. **検索フロー**: 入力テキスト → ベクトル変換 → メタデータフィルタ付き検索 → 類似工種提示

**技術スタック**:
- フロントエンド: React + TypeScript + Zod
- バックエンド: TypeScript + Prisma + PostgreSQL
- AI処理: Python + LangChain + OpenAI Embeddings
- イベント配信: AWS EventBridge
-

Wiki pages you might want to explore:
- [Core Business Domains (KENCOPA/kunai-core-backend)](/wiki/KENCOPA/kunai-core-backend#2)

### Citations

**File:** prisma/schema.prisma (L421-480)
```text
  scheduleActivityDetail   ScheduleActivityDetail   @relation(fields: [activityDetailId], references: [id], onDelete: Cascade)
  scheduleActivityWorkType ScheduleActivityWorkType @relation(fields: [activityWorkTypeId], references: [id], onDelete: Cascade)
  tenantWorkUnit           TenantWorkUnit           @relation(fields: [tenantWorkUnitId], references: [id], onDelete: Cascade)

  @@unique([activityWorkTypeId, tenantWorkUnitId])
  @@map("schedule_activity_work_units")
}

// 工種マスタ（システム共通）
model WorkType {
  id              String   @id @default(uuid())
  majorCategoryId String   @map("major_category_id")
  name            String
  description     String?
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // relations
  majorCategory MajorCategory @relation(fields: [majorCategoryId], references: [id], onDelete: Cascade)
  workUnits     WorkUnit[]

  @@unique([majorCategoryId, name])
  @@map("work_types")
}

// 細別マスタ（システム共通）
model WorkUnit {
  id          String   @id @default(uuid())
  workTypeId  String   @map("work_type_id")
  name        String
  description String?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // relations
  workType WorkType @relation(fields: [workTypeId], references: [id], onDelete: Cascade)

  @@unique([workTypeId, name])
  @@map("work_units")
}

// 工種体系マスタ（システム共通）
model WorkTypeMaster {
  id             String   @id @default(uuid())
  name           String   @unique
  description    String?
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // relations
  majorCategories MajorCategory[]

  @@map("work_type_masters")
}

// 大分類（システム共通）
model MajorCategory {
  id                 String   @id @default(uuid())
  workTypeMasterId   String   @map("work_type_master_id")
  name               String
```
