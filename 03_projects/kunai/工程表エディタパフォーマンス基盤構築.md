---
type: note
moc: "[[üè∑Ô∏èÂü∫Êú¨Ë®≠Ë®àÊõ∏]]"
tags:
- '#ai/ref'
---
# Ê¶ÇË¶Å

AOAÂûãÂ∑•Á®ãË°®„Ç®„Éá„Ç£„Çø„ÅÆÈñãÁô∫„ÉªÊ§úË®º„Éï„Çß„Éº„Ç∫„Å´„Åä„ÅÑ„Å¶„ÄÅ„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂïèÈ°å„ÅÆÊó©ÊúüÁô∫Ë¶ã„Å®Á∂ôÁ∂öÁöÑÁõ£Ë¶ñ„ÇíË°å„ÅÜ„Åü„ÇÅ„ÅÆ„Éá„Éê„ÉÉ„Ç∞„ÉÑ„Éº„É´„ÇíÊßãÁØâ„Åô„Çã„ÄÇÊú¨„ÉÑ„Éº„É´„ÅØ„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÊôÇ„ÅÆ„ÅøÂãï‰Ωú„Åó„ÄÅÈñãÁô∫ËÄÖ„Åå„É™„Ç¢„É´„Çø„Ç§„É†„Åß„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊåáÊ®ô„ÇíÁõ£Ë¶ñ„ÉªÂàÜÊûê„Åß„Åç„ÇãÊ©üËÉΩ„ÇíÊèê‰æõ„Åô„Çã„ÄÇ

# Ê∏¨ÂÆöÂØæË±°„Å®„Åù„ÅÆÁõÆÁöÑ

Êú¨„Éá„Éê„ÉÉ„Ç∞„ÉÑ„Éº„É´„Åß„ÅØ‰ª•‰∏ã„ÅÆÊåáÊ®ô„ÇíÊ∏¨ÂÆö„Åô„ÇãÔºö

- **FPS (Frames Per Second)** - „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÉªÊèèÁîª„ÅÆ„Éï„É¨„Éº„É†„É¨„Éº„Éà
- **„É°„É¢„É™‰ΩøÁî®Èáè** - JS„Éí„Éº„Éó„Çµ„Ç§„Ç∫„ÄÅ„É°„É¢„É™„É™„Éº„ÇØÊ§úÂá∫
- **Âá¶ÁêÜÊôÇÈñì** - ÊèèÁîª„ÉªÊìç‰Ωú„ÉªÊõ¥Êñ∞Âá¶ÁêÜ„ÅÆÂÆüË°åÊôÇÈñì
- **DOM/SVGË¶ÅÁ¥†Êï∞** - „Çø„Çπ„ÇØ„Éª„Ç¢„Éé„ÉÜ„Éº„Ç∑„Éß„É≥Ë¶ÅÁ¥†„ÅÆÁ∑èÊï∞
- **„Ç§„Éô„É≥„ÉàÂá¶ÁêÜÊÄßËÉΩ** - „Éû„Ç¶„Çπ„Éª„Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú„ÅÆÂøúÁ≠îÊôÇÈñì
- **Undo/RedoÊÄßËÉΩ** - Â±•Ê≠¥ÁÆ°ÁêÜ„Å®Áä∂ÊÖãÂæ©ÂÖÉ„ÅÆÂá¶ÁêÜÊôÇÈñì

## FPS (Frames Per Second)
**Ê∏¨ÂÆö„Åô„ÇãÁêÜÁî±**: 
- „É¶„Éº„Ç∂„Éº„ÅÆÊìç‰ΩúÊÑü„Å´Áõ¥Áµê„Åô„ÇãÊúÄÈáçË¶ÅÊåáÊ®ô
- „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÉªÊèèÁîªÂá¶ÁêÜ„ÅÆÊÄßËÉΩÂä£Âåñ„ÇíÂç≥Â∫ß„Å´Ê§úÂá∫
- „Éï„É¨„Éº„É†ËêΩ„Å°„Å´„Çà„ÇãUXÊÇ™Âåñ„ÇíÈò≤Ê≠¢

**Ê∏¨ÂÆöÂÜÖÂÆπ**:
- **Ê∏¨ÂÆö„Çø„Ç§„Éü„É≥„Ç∞**: „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„ÉóÔºà„Éñ„É©„Ç¶„Ç∂„ÅÆÊèèÁîª„Çø„Ç§„Éü„É≥„Ç∞Ôºâ„Åß„ÅÆÈÄ£Á∂öÊ∏¨ÂÆö
- **ÁÆóÂá∫ÊñπÊ≥ï**: 1ÁßíÈñì„ÅÆ„Éï„É¨„Éº„É†Êï∞„Çí„Ç´„Ç¶„É≥„Éà
- **Ë°®Á§∫ÂΩ¢Âºè**: „É™„Ç¢„É´„Çø„Ç§„É†Êï∞ÂÄ§„ÄÅËâ≤ÂàÜ„Åë„Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫ÔºàÁ∑ë/ÈªÑ/Ëµ§Ôºâ

## „É°„É¢„É™‰ΩøÁî®Èáè
**Ê∏¨ÂÆö„Åô„ÇãÁêÜÁî±**:
- „É°„É¢„É™„É™„Éº„ÇØ„ÅÆÊó©ÊúüÁô∫Ë¶ãÔºàÈï∑ÊôÇÈñìÊìç‰Ωú„Åß„ÅÆÊÄ•ÊøÄ„Å™Â¢óÂä†Ôºâ
- „Éñ„É©„Ç¶„Ç∂„ÇØ„É©„ÉÉ„Ç∑„É•„ÉªÂãï‰Ωú‰∏çÂÆâÂÆö„ÅÆ‰∫àÈò≤
- Â§ßÈáè„Éá„Éº„ÇøÂá¶ÁêÜÊôÇ„ÅÆ„É°„É¢„É™ÂäπÁéáÊ§úË®º

**Ê∏¨ÂÆöÂÜÖÂÆπ**:
- **Ê∏¨ÂÆöÈ†ÖÁõÆ**: `performance.memory`APIÔºàusedJSHeapSize, totalJSHeapSize, jsHeapSizeLimitÔºâ
- **Ê∏¨ÂÆöÈñìÈöî**: 5ÁßíÈñìÈöî„Åß„ÅÆÂÆöÊúüÂèñÂæó
- **Ë°®Á§∫ÂΩ¢Âºè**: MBÂçò‰Ωç„ÄÅÊôÇÁ≥ªÂàó„Ç∞„É©„Éï„ÄÅÂ¢óÂä†ÂÇæÂêë„Ç¢„É©„Éº„Éà

## Âá¶ÁêÜÊôÇÈñì
**Ê∏¨ÂÆö„Åô„ÇãÁêÜÁî±**:
- Èáç„ÅÑÂá¶ÁêÜ„Å´„Çà„Çã„É°„Ç§„É≥„Çπ„É¨„ÉÉ„Éâ„Éñ„É≠„ÉÉ„ÇØÊ§úÂá∫
- „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„Å´ÂØæ„Åô„Çã„É¨„Çπ„Éù„É≥„ÇπÊÄßËÉΩ„ÅÆÂÆöÈáèË©ï‰æ°
- Âá¶ÁêÜÂäπÁéá„ÅÆÊîπÂñÑ„Éù„Ç§„É≥„ÉàÁâπÂÆö

**Ê∏¨ÂÆöÂÜÖÂÆπ**:
- **Ê∏¨ÂÆöÈ†ÖÁõÆ**: ÊèèÁîªÂá¶ÁêÜ„ÄÅ„Éâ„É©„ÉÉ„Ç∞Êìç‰Ωú„ÄÅ„Çø„Çπ„ÇØÁîüÊàê„ÉªÊõ¥Êñ∞„ÄÅDOM/SVGË¶ÅÁ¥†Êìç‰Ωú„ÄÅUndo/RedoÂá¶ÁêÜ
- **Ê∏¨ÂÆöÊñπÊ≥ï**: `performance.now()`„Å´„Çà„ÇãÈ´òÁ≤æÂ∫¶ÊôÇÈñìË®àÊ∏¨
- **Ë°®Á§∫ÂΩ¢Âºè**: msÂçò‰Ωç„ÄÅÁµ±Ë®àÊÉÖÂ†±ÔºàÂπ≥Âùá„ÉªÊúÄÂ§ß„ÉªP95Ôºâ„ÄÅË≠¶Âëä„Ç¢„É©„Éº„Éà

## DOM/SVGË¶ÅÁ¥†Êï∞
**Ê∏¨ÂÆö„Åô„ÇãÁêÜÁî±**:
- Â§ßÈáèË¶ÅÁ¥†„Å´„Çà„ÇãÊèèÁîªÊÄßËÉΩÂä£Âåñ„ÅÆÁõ£Ë¶ñ
- „É°„É¢„É™‰ΩøÁî®ÈáèÂ¢óÂä†Ë¶ÅÂõ†„ÅÆÁâπÂÆö
- „Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£ÈôêÁïå„ÅÆÊääÊè°

**Ê∏¨ÂÆöÂÜÖÂÆπ**:
- **Ê∏¨ÂÆöÈ†ÖÁõÆ**: AOA„Çø„Çπ„ÇØË¶ÅÁ¥†„ÄÅ„Ç¢„Éé„ÉÜ„Éº„Ç∑„Éß„É≥Ë¶ÅÁ¥†Ôºà„ÉÜ„Ç≠„Çπ„Éà„ÉªÂõ≥ÂΩ¢„ÉªÁîªÂÉèÔºâ„ÄÅÁ∑èDOMË¶ÅÁ¥†Êï∞„ÄÅSVG„Ç∞„É´„Éº„ÉóÊï∞
- **Ê∏¨ÂÆö„Çø„Ç§„Éü„É≥„Ç∞**: `MutationObserver`„Å´„Çà„ÇãË¶ÅÁ¥†ËøΩÂä†„ÉªÂâäÈô§ÊôÇ„ÅÆËá™ÂãïÁõ£Ë¶ñ
- **Ë°®Á§∫ÂΩ¢Âºè**: Ë¶ÅÁ¥†Á®ÆÂà•„Åî„Å®„ÅÆ„Ç´„Ç¶„É≥„Éà„ÄÅÂ¢óÊ∏õÂ±•Ê≠¥„ÄÅÈñæÂÄ§Ë≠¶Âëä

## „Ç§„Éô„É≥„ÉàÂá¶ÁêÜÊÄßËÉΩ
**Ê∏¨ÂÆö„Åô„ÇãÁêÜÁî±**:
- „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„ÅÆÂøúÁ≠îÊÄßÁ¢∫‰øù
- „Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº„ÅÆÂá¶ÁêÜÂäπÁéáÊ§úË®º
- Êìç‰ΩúÈÅÖÂª∂„Å´„Çà„Çã‰ΩìÈ®ìÊÇ™Âåñ„ÅÆÈò≤Ê≠¢

**Ê∏¨ÂÆöÂÜÖÂÆπ**:
- **Ê∏¨ÂÆöÈ†ÖÁõÆ**: „Éû„Ç¶„Çπ„Ç§„Éô„É≥„ÉàÔºàclick, mousemoveÁ≠âÔºâ„ÄÅ„Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà„ÄÅ„Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„ÉàÔºàÂ∞ÜÊù•ÂØæÂøúÔºâ
- **Ê∏¨ÂÆöÊñπÊ≥ï**: „Ç≠„É£„Éó„ÉÅ„É£„Éï„Çß„Éº„Ç∫„Åß„ÅÆ„Ç§„Éô„É≥„ÉàÂá¶ÁêÜÊôÇÈñìË®àÊ∏¨
- **Ë°®Á§∫ÂΩ¢Âºè**: „Ç§„Éô„É≥„ÉàÁ®ÆÂà•„Åî„Å®„ÅÆÁµ±Ë®à„ÄÅÁï∞Â∏∏ÂÄ§„Ç¢„É©„Éº„ÉàÔºà100msË∂ÖÈÅéÊôÇÔºâ

## Undo/RedoÊÄßËÉΩ
**Ê∏¨ÂÆö„Åô„ÇãÁêÜÁî±**:
- Â§ßÈáè„Éá„Éº„ÇøÂ§âÊõ¥ÊôÇ„ÅÆÁä∂ÊÖãÂæ©ÂÖÉÊôÇÈñì„ÅÆÁõ£Ë¶ñ
- „É°„É¢„É™‰ΩøÁî®ÈáèÂ¢óÂä†ÔºàÂ±•Ê≠¥„Éá„Éº„ÇøËìÑÁ©çÔºâ„ÅÆËøΩË∑°
- „É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£„Å´Áõ¥Áµê„Åô„ÇãÊìç‰ΩúÂøúÁ≠îÊÄß„ÅÆÁ¢∫‰øù

**Ê∏¨ÂÆöÂÜÖÂÆπ**:
- **Ê∏¨ÂÆöÈ†ÖÁõÆ**: UndoÂÆüË°åÊôÇÈñì„ÄÅRedoÂÆüË°åÊôÇÈñì„ÄÅÂ±•Ê≠¥„Éá„Éº„Çø„Çµ„Ç§„Ç∫„ÄÅÂ±•Ê≠¥‰øùÂ≠òÂá¶ÁêÜÊôÇÈñì
- **Ê∏¨ÂÆöÊñπÊ≥ï**: Êìç‰ΩúÈñãÂßã„Åã„ÇâÁä∂ÊÖãÂæ©ÂÖÉÂÆå‰∫Ü„Åæ„Åß„ÅÆÊôÇÈñìË®àÊ∏¨
- **Ë°®Á§∫ÂΩ¢Âºè**: ÂÆüË°åÊôÇÈñìÁµ±Ë®à„ÄÅÂ±•Ê≠¥„É°„É¢„É™‰ΩøÁî®Èáè„ÄÅÊìç‰ΩúÂõûÊï∞„Ç´„Ç¶„É≥„Éà

# „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÊ©üËÉΩ

## „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ
- **Ë°®Á§∫‰ΩçÁΩÆ**: ÁîªÈù¢Âè≥‰∏ä„Åæ„Åü„ÅØÂ∑¶‰∏ã„ÅÆ„Ç™„Éº„Éê„Éº„É¨„Ç§
- **Ë°®Á§∫ÂÜÖÂÆπ**:
  - FPSÔºà„É™„Ç¢„É´„Çø„Ç§„É†Ôºâ
  - „É°„É¢„É™‰ΩøÁî®ÈáèÔºàÁèæÂú®ÂÄ§„ÉªÊé®ÁßªÔºâ
  - ÊèèÁîªÂá¶ÁêÜÊôÇÈñìÔºàÂπ≥Âùá„ÉªÊúÄÂ§ßÔºâ
  - Ë¶ÅÁ¥†Êï∞Ôºà„Çø„Çπ„ÇØ„Éª„Ç¢„Éé„ÉÜ„Éº„Ç∑„Éß„É≥Ôºâ
  - Ë≠¶Âëä„Éª„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏

## „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÂàá„ÇäÊõø„Åà
- **ÊúâÂäπÂåñÊñπÊ≥ï**:
  - URL„Éë„É©„É°„Éº„Çø: `?debug=true`
  - „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: `Ctrl+Shift+D`
  - Ë®≠ÂÆö„Éë„Éç„É´„Åã„Çâ„ÅÆÂàá„ÇäÊõø„Åà
- **ÈùûË°®Á§∫Êù°‰ª∂**: Êú¨Áï™Áí∞Â¢É„Åß„ÅØËá™ÂãïÁöÑ„Å´ÁÑ°ÂäπÂåñ

## „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË®òÈå≤„Éª„Ç®„ÇØ„Çπ„Éù„Éº„Éà
- **Ë®òÈå≤ÂΩ¢Âºè**: JSONÂΩ¢Âºè„Åß„ÅÆ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É≠„Ç∞
- **„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ©üËÉΩ**: CSV/JSONÂΩ¢Âºè„Åß„ÅÆ„Éá„Éº„Çø„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ
- **Ë®òÈå≤È†ÖÁõÆ**:
  - „Çø„Ç§„É†„Çπ„Çø„É≥„Éó
  - FPSÂÄ§
  - „É°„É¢„É™‰ΩøÁî®Èáè
  - Âá¶ÁêÜÊôÇÈñì
  - „É¶„Éº„Ç∂„ÉºÊìç‰Ωú„É≠„Ç∞

# ÂÆüË£Ö„Ç¢„Éó„É≠„Éº„ÉÅ

## „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ê¶ÇË¶Å
„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ„Éá„Éê„ÉÉ„Ç∞„ÉÑ„Éº„É´„ÅØ‰ª•‰∏ã„ÅÆÊßãÊàê„ÅßÂÆüË£Ö„Åô„ÇãÔºö

- **PerformanceMonitor**: ÂêÑÊ∏¨ÂÆö„ÇØ„É©„Çπ„ÇíÁµ±ÂêàÁÆ°ÁêÜ„Åô„Çã„É°„Ç§„É≥„ÇØ„É©„Çπ
- **ÂÄãÂà•Ê∏¨ÂÆö„ÇØ„É©„Çπ**: FPSCounter, MemoryMonitor, TimingMonitor, ElementCounter, EventPerformanceMonitor
- **DebugDashboard**: UIË°®Á§∫„ÉªÂà∂Âæ°„ÇíÊãÖÂΩì
- **DataExporter**: Ê∏¨ÂÆö„Éá„Éº„Çø„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ©üËÉΩ

## Êó¢Â≠ò„Éó„É≠„Éà„Çø„Ç§„Éó„Å∏„ÅÆÁµ±ÂêàÊñπÈáù
**CanvasÁâà (canvas-grid-snapping-annotation.html)**:
- Êó¢Â≠ò„ÅÆFPSË®àÊ∏¨Ê©üËÉΩÔºà1498-1512Ë°åÔºâ„ÇíÊã°Âºµ
- CanvasÊèèÁîªÂá¶ÁêÜÊôÇÈñì„ÅÆÊ∏¨ÂÆö„ÇíËøΩÂä†
- DOMË¶ÅÁ¥†Áõ£Ë¶ñ„Å®„É°„É¢„É™Áõ£Ë¶ñ„ÅÆÁµ±Âêà

**SVGÁâà (svg-grid-snapping-annotation.html)**:
- Êó¢Â≠ò„ÅÆFPSË®àÊ∏¨Ê©üËÉΩÔºà402-427Ë°åÔºâ„ÇíÊã°Âºµ
- SVGË¶ÅÁ¥†Êìç‰ΩúÂá¶ÁêÜÊôÇÈñì„ÅÆÊ∏¨ÂÆö„ÇíËøΩÂä†
- SVGË¶ÅÁ¥†Êï∞„ÅÆË©≥Á¥∞Áõ£Ë¶ñ

# ÊäÄË°ìÊ§úË®é‰∫ãÈ†Ö

## Ê∏¨ÂÆö„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„ÅÆÊúÄÂ∞èÂåñ
- „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊ∏¨ÂÆöËá™‰Ωì„ÅåÊÄßËÉΩ„Å´ÂΩ±Èüø„Åó„Å™„ÅÑ„Çà„ÅÜÈÖçÊÖÆ
- Ê∏¨ÂÆöÈñìÈöî„ÅÆË™øÊï¥ÔºàÈ´òÈ†ªÂ∫¶Ê∏¨ÂÆö vs ‰Ωé„Ç™„Éº„Éê„Éº„Éò„ÉÉ„ÉâÔºâ
- „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ„Åß„ÅÆ„ÅøÊúâÂäπÂåñ

## „Éñ„É©„Ç¶„Ç∂‰∫íÊèõÊÄß
- Chrome DevTools API„ÅÆÊ¥ªÁî®
- Safari„ÄÅFirefox„Åß„ÅÆ‰ª£ÊõøÊâãÊÆµ
- „É¢„Éê„Ç§„É´„Éñ„É©„Ç¶„Ç∂„Åß„ÅÆÊ∏¨ÂÆöÂà∂Èôê

## Ë¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
- „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁä∂ÊÖã„ÅÆÁõ¥ÊÑüÁöÑ„Å™Ë°®Á§∫
- ÈñæÂÄ§Ë∂ÖÈÅéÊôÇ„ÅÆË≠¶ÂëäË°®Á§∫
- „É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£„ÇíÊêç„Å™„Çè„Å™„ÅÑUIË®≠Ë®à

# „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñ„Å´„Çà„Çã„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ

## Ê∏¨ÂÆöÊ©üËÉΩ„Å´„Çà„ÇãÊÄßËÉΩÂΩ±Èüø

„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁõ£Ë¶ñÊ©üËÉΩ„ÅÆÂ∞éÂÖ•„Å´„Çà„Çä„ÄÅÊú¨Êù•„ÅÆ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÊÄßËÉΩ„Å´‰ª•‰∏ã„ÅÆÂΩ±Èüø„ÅåÁîü„Åò„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„ÇãÔºö

### FPSÊ∏¨ÂÆö„Å´„Çà„Çã„Éï„É¨„Éº„É†„É¨„Éº„Éà‰Ωé‰∏ã
- **requestAnimationFrame**„ÅÆËøΩÂä†ÂÆüË°å„Å´„Çà„Çä1-3FPSÁ®ãÂ∫¶„ÅÆ‰Ωé‰∏ã
- Â§ßÈáèË¶ÅÁ¥†ÊèèÁîªÊôÇÔºà1000+Ë¶ÅÁ¥†Ôºâ„Åß„ÅØÊúÄÂ§ß5%„ÅÆÊÄßËÉΩ‰Ωé‰∏ã
- ÊØé„Éï„É¨„Éº„É†ÂÆüË°å„Åï„Çå„ÇãË®àÁÆóÂá¶ÁêÜ„ÅÆÁ¥ØÁ©çÂäπÊûú

### „É°„É¢„É™„ÉªÂá¶ÁêÜÊôÇÈñìÊ∏¨ÂÆö„ÅÆ„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ
- **performance.memory**APIÂëº„Å≥Âá∫„ÅóÔºà5ÁßíÈñìÈöîÔºâÔºöËªΩÂæÆ
- **performance.now()**„Å´„Çà„ÇãÊôÇÈñìÊ∏¨ÂÆöÔºöÊ∏¨ÂÆöÂØæË±°Âá¶ÁêÜ„Å´ÂØæ„Åó„Å¶1-2%„ÅÆËøΩÂä†Âá¶ÁêÜÊôÇÈñì
- „Ç§„Éô„É≥„Éà„Ç≠„É£„Éó„ÉÅ„É£„Éï„Çß„Éº„Ç∫„Åß„ÅÆÊ∏¨ÂÆöÂá¶ÁêÜÔºöÂÖ®„Ç§„Éô„É≥„Éà„Å´ÂØæ„Åô„ÇãËªΩÂæÆ„Å™ÈÅÖÂª∂

### DOM/SVGË¶ÅÁ¥†Áõ£Ë¶ñ„ÅÆÂΩ±Èüø
- **MutationObserver**„Å´„Çà„ÇãDOMÂ§âÊõ¥Áõ£Ë¶ñÔºöË¶ÅÁ¥†ËøΩÂä†„ÉªÂâäÈô§ÊôÇ„ÅÆËªΩÂæÆ„Å™Âá¶ÁêÜË≤†Ëç∑
- Ë¶ÅÁ¥†„Ç´„Ç¶„É≥„ÉàÂá¶ÁêÜÔºöquerySelectorÂÆüË°å„Å´„Çà„Çã„Çè„Åö„Åã„Å™Ë≤†Ëç∑

## „Ç™„Éº„Éê„Éº„Éò„ÉÉ„ÉâÊúÄÂ∞èÂåñÂØæÁ≠ñ

### 1. Ê∏¨ÂÆöÈ†ªÂ∫¶„ÅÆË™øÊï¥
```typescript
// È´òÁ≤æÂ∫¶ vs ‰Ωé„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„ÅÆÈÅ∏Êäû
const precision = process.env.NODE_ENV === 'development' ? 'high' : 'low';
const skipRate = precision === 'high' ? 1 : 5; // 5„Éï„É¨„Éº„É†„Å´1ÂõûÊ∏¨ÂÆö
```

### 2. „Çµ„É≥„Éó„É™„É≥„Ç∞Ê∏¨ÂÆö
```typescript
// Á¢∫ÁéáÁöÑÊ∏¨ÂÆö„Åß„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„ÇíÂâäÊ∏õ
if (Math.random() > 0.8) { // 20%„ÅÆÁ¢∫Áéá„ÅßÊ∏¨ÂÆö
  measureEventPerformance(event);
}
```

### 3. „Ç¢„Ç§„Éâ„É´ÊôÇÊ∏¨ÂÆö
```typescript
// „Éñ„É©„Ç¶„Ç∂„ÅÆ„Ç¢„Ç§„Éâ„É´ÊôÇÈñì„ÇíÊ¥ªÁî®
requestIdleCallback(() => {
  updatePerformanceMetrics();
});
```

### 4. Êù°‰ª∂‰ªò„ÅçÁÑ°ÂäπÂåñ
```typescript
const config = {
  enabled: process.env.NODE_ENV === 'development' && window.location.search.includes('debug=true'),
  lightMode: true // ËªΩÈáèÊ∏¨ÂÆö„É¢„Éº„Éâ
};
```

## Êé®Â•®ÈÅãÁî®ÊñπÈáù

- **ÈñãÁô∫Áí∞Â¢É**: Ë©≥Á¥∞Ê∏¨ÂÆö„ÇíÊúâÂäπÂåñ„Åó„Å¶„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂïèÈ°å„ÇíÊó©ÊúüÁô∫Ë¶ã
- **„Çπ„ÉÜ„Éº„Ç∏„É≥„Ç∞Áí∞Â¢É**: ËªΩÈáè„É¢„Éº„Éâ„ÅßÂü∫Êú¨ÁöÑ„Å™Áõ£Ë¶ñ„ÅÆ„ÅøÂÆüÊñΩ
- **Êú¨Áï™Áí∞Â¢É**: ÂÆåÂÖ®ÁÑ°ÂäπÂåñ„Åæ„Åü„ÅØ„Çµ„É≥„Éó„É™„É≥„Ç∞Ê∏¨ÂÆöÔºà1%Á®ãÂ∫¶Ôºâ
- **ÊÄßËÉΩÊ§úË®ºÊôÇ**: Ê∏¨ÂÆöÊ©üËÉΩ„ÇíÁÑ°ÂäπÂåñ„Åó„ÅüÁä∂ÊÖã„Åß„ÅÆÊÄßËÉΩÊ∏¨ÂÆö„ÇÇ‰Ωµ„Åõ„Å¶ÂÆüÊñΩ

„Åì„ÅÆÁõ£Ë¶ñ„Ç™„Éº„Éê„Éº„Éò„ÉÉ„Éâ„ÇíËÄÉÊÖÆ„Åó„Åü‰∏ä„Åß„ÄÅÈñãÁô∫ÂäπÁéá„Å®„ÅÆ„Éê„É©„É≥„Çπ„ÇíÂèñ„Çä„Å™„Åå„ÇâÈÅ©Âàá„Å™Ê∏¨ÂÆö„É¨„Éô„É´„ÇíÈÅ∏Êäû„Åô„Çã„Åì„Å®„ÅåÈáçË¶Å„Åß„ÅÇ„Çã„ÄÇ

# ÂÆüË£ÖË©≥Á¥∞

## FPSÊ∏¨ÂÆöÂÆüË£Ö (Next.js)
```typescript
// hooks/usePerformanceMonitor.ts
import { useEffect, useRef, useCallback } from 'react';

interface FPSMetrics {
  fps: number;
  status: 'good' | 'warning' | 'error';
}

export const useFPSMonitor = (enabled: boolean = false) => {
  const fpsRef = useRef(0);
  const frameCountRef = useRef(0);
  const lastTimeRef = useRef(performance.now());
  const animationIdRef = useRef<number>();
  const displayCallbackRef = useRef<(metrics: FPSMetrics) => void>();

  const updateFPS = useCallback(() => {
    const now = performance.now();
    frameCountRef.current++;

    if (now - lastTimeRef.current >= 1000) {
      const fps = Math.round((frameCountRef.current * 1000) / (now - lastTimeRef.current));
      const status: FPSMetrics['status'] = fps >= 55 ? 'good' : fps >= 30 ? 'warning' : 'error';
      
      fpsRef.current = fps;
      
      // React state„Çí‰Ωø„Çè„Åö„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÅßÈÄöÁü•
      displayCallbackRef.current?.({ fps, status });
      
      frameCountRef.current = 0;
      lastTimeRef.current = now;
    }

    if (enabled) {
      animationIdRef.current = requestAnimationFrame(updateFPS);
    }
  }, [enabled]);

  useEffect(() => {
    if (!enabled) {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
      return;
    }

    animationIdRef.current = requestAnimationFrame(updateFPS);

    return () => {
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current);
      }
    };
  }, [enabled, updateFPS]);

  const registerDisplayCallback = useCallback((callback: (metrics: FPSMetrics) => void) => {
    displayCallbackRef.current = callback;
  }, []);

  return { 
    getCurrentFPS: () => fpsRef.current,
    registerDisplayCallback
  };
};
```

## „É°„É¢„É™Áõ£Ë¶ñÂÆüË£Ö (Next.js)
```typescript
// hooks/useMemoryMonitor.ts
import { useEffect, useRef, useCallback } from 'react';

interface MemoryMetrics {
  used: number;
  total: number;
  limit: number;
  timestamp: number;
}

interface MemoryHistory extends MemoryMetrics {
  trend?: 'increasing' | 'stable' | 'decreasing';
}

export const useMemoryMonitor = (enabled: boolean = false, interval: number = 5000) => {
  const historyRef = useRef<MemoryHistory[]>([]);
  const intervalIdRef = useRef<NodeJS.Timeout>();
  const callbackRef = useRef<(data: MemoryHistory) => void>();

  const measure = useCallback(() => {
    if (typeof window === 'undefined' || !('performance' in window) || !performance.memory) {
      console.warn('performance.memory API not available');
      return;
    }

    const memory: MemoryMetrics = {
      timestamp: Date.now(),
      used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024), // MB
      total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
      limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
    };

    // Â±•Ê≠¥„Å´ËøΩÂä†
    historyRef.current.push(memory);
    if (historyRef.current.length > 60) { // 5ÂàÜÈñì„ÅÆÂ±•Ê≠¥Ôºà5ÁßíÈñìÈöîÔºâ
      historyRef.current.shift();
    }

    // „É°„É¢„É™„É™„Éº„ÇØÊ§úÂá∫
    const leak = checkMemoryLeak();
    const trend = getTrend();
    
    const memoryWithTrend: MemoryHistory = { ...memory, trend };
    callbackRef.current?.(memoryWithTrend);

    if (leak) {
      console.warn('Potential memory leak detected:', leak, 'MB increase');
    }
  }, []);

  const checkMemoryLeak = useCallback(() => {
    if (historyRef.current.length < 6) return null;
    
    const recent = historyRef.current.slice(-6); // Áõ¥Ëøë30Áßí
    const trend = recent[recent.length - 1].used - recent[0].used;
    
    return trend > 50 ? trend : null;
  }, []);

  const getTrend = useCallback(() => {
    if (historyRef.current.length < 3) return 'stable';
    
    const recent = historyRef.current.slice(-3);
    const avgChange = (recent[2].used - recent[0].used) / 2;
    
    if (avgChange > 5) return 'increasing';
    if (avgChange < -5) return 'decreasing';
    return 'stable';
  }, []);

  useEffect(() => {
    if (!enabled) {
      if (intervalIdRef.current) {
        clearInterval(intervalIdRef.current);
      }
      return;
    }

    // ÂàùÂõûÊ∏¨ÂÆö
    measure();
    
    // ÂÆöÊúüÊ∏¨ÂÆö
    intervalIdRef.current = setInterval(measure, interval);

    return () => {
      if (intervalIdRef.current) {
        clearInterval(intervalIdRef.current);
      }
    };
  }, [enabled, interval, measure]);

  const registerCallback = useCallback((callback: (data: MemoryHistory) => void) => {
    callbackRef.current = callback;
  }, []);

  return {
    getHistory: () => historyRef.current,
    getCurrentMemory: () => historyRef.current[historyRef.current.length - 1],
    registerCallback
  };
};
```

## Âá¶ÁêÜÊôÇÈñìÊ∏¨ÂÆöÂÆüË£Ö (Next.js)
```typescript
// hooks/useTimingMonitor.ts
import { useRef, useCallback } from 'react';

type TimingCategory = 'rendering' | 'interaction' | 'taskOperation' | 'undoRedo';

interface TimingMetrics {
  category: TimingCategory;
  duration: number;
  timestamp: number;
}

interface TimingStats {
  avg: number;
  max: number;
  p95: number;
  count: number;
}

export const useTimingMonitor = (enabled: boolean = false) => {
  const measurementsRef = useRef<Record<TimingCategory, TimingMetrics[]>>({
    rendering: [],
    interaction: [],
    taskOperation: [],
    undoRedo: []
  });
  
  const callbackRef = useRef<(category: TimingCategory, stats: TimingStats) => void>();

  const startTimer = useCallback((category: TimingCategory) => {
    if (!enabled) return { end: () => {} };

    const startTime = performance.now();
    
    return {
      end: () => {
        const duration = performance.now() - startTime;
        const measurement: TimingMetrics = {
          category,
          duration,
          timestamp: Date.now()
        };

        // Ê∏¨ÂÆö„Éá„Éº„Çø„Çí‰øùÂ≠ò
        measurementsRef.current[category].push(measurement);
        
        // Áõ¥Ëøë100‰ª∂„ÅÆ„Åø‰øùÊåÅ
        if (measurementsRef.current[category].length > 100) {
          measurementsRef.current[category].shift();
        }

        // Áµ±Ë®àË®àÁÆó
        const stats = calculateStats(category);
        callbackRef.current?.(category, stats);

        // Ë≠¶Âëä„É¨„Éô„É´„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
        if (duration > 16.67) { // 60FPS threshold
          console.warn(`Long running ${category}:`, duration.toFixed(2), 'ms');
        }

        return duration;
      }
    };
  }, [enabled]);

  const calculateStats = useCallback((category: TimingCategory): TimingStats => {
    const data = measurementsRef.current[category];
    if (data.length === 0) {
      return { avg: 0, max: 0, p95: 0, count: 0 };
    }

    const durations = data.map(item => item.duration);
    const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
    const max = Math.max(...durations);
    const sorted = [...durations].sort((a, b) => a - b);
    const p95 = sorted[Math.floor(sorted.length * 0.95)] || 0;

    return {
      avg: Number(avg.toFixed(2)),
      max: Number(max.toFixed(2)),
      p95: Number(p95.toFixed(2)),
      count: data.length
    };
  }, []);

  const getStats = useCallback((category: TimingCategory) => {
    return calculateStats(category);
  }, [calculateStats]);

  const getAllStats = useCallback(() => {
    const categories: TimingCategory[] = ['rendering', 'interaction', 'taskOperation', 'undoRedo'];
    return categories.reduce((acc, category) => {
      acc[category] = calculateStats(category);
      return acc;
    }, {} as Record<TimingCategory, TimingStats>);
  }, [calculateStats]);

  const registerCallback = useCallback((callback: (category: TimingCategory, stats: TimingStats) => void) => {
    callbackRef.current = callback;
  }, []);

  return {
    startTimer,
    getStats,
    getAllStats,
    registerCallback
  };
};

// ‰ΩøÁî®‰æã: „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂÜÖ„Åß„ÅÆÂá¶ÁêÜÊôÇÈñìÊ∏¨ÂÆö
export const useRenderingTimer = () => {
  const { startTimer } = useTimingMonitor(true);
  
  return useCallback((renderFunction: () => void) => {
    const timer = startTimer('rendering');
    renderFunction();
    timer.end();
  }, [startTimer]);
};
```

## DOM/SVGË¶ÅÁ¥†Áõ£Ë¶ñÂÆüË£Ö
```javascript
class ElementCounter {
  constructor() {
    this.counts = {
      aoaTasks: 0,
      annotations: { text: 0, shape: 0, image: 0 },
      totalDOM: 0,
      svgGroups: 0
    };
    this.history = [];
  }
  
  updateCounts() {
    // AOA„Çø„Çπ„ÇØË¶ÅÁ¥†
    this.counts.aoaTasks = document.querySelectorAll('[data-task-id]').length;
    
    // „Ç¢„Éé„ÉÜ„Éº„Ç∑„Éß„É≥Ë¶ÅÁ¥†
    this.counts.annotations.text = document.querySelectorAll('[data-type="text"]').length;
    this.counts.annotations.shape = document.querySelectorAll('[data-type="shape"]').length;
    this.counts.annotations.image = document.querySelectorAll('[data-type="image"]').length;
    
    // Á∑èDOMË¶ÅÁ¥†Êï∞
    this.counts.totalDOM = document.querySelectorAll('*').length;
    
    // SVG„Ç∞„É´„Éº„ÉóÊï∞
    this.counts.svgGroups = document.querySelectorAll('svg g').length;
    
    // Â±•Ê≠¥Ë®òÈå≤
    this.history.push({
      timestamp: Date.now(),
      ...JSON.parse(JSON.stringify(this.counts))
    });
    
    // Áõ¥Ëøë50‰ª∂„ÅÆ„Åø‰øùÊåÅ
    if (this.history.length > 50) {
      this.history.shift();
    }
    
    this.updateDisplay();
    this.checkThresholds();
  }
  
  checkThresholds() {
    const total = this.counts.aoaTasks + 
                  this.counts.annotations.text + 
                  this.counts.annotations.shape + 
                  this.counts.annotations.image;
    
    if (total > 1000) {
      console.warn('Element count approaching limit:', total);
    }
  }
}
```

## „Ç§„Éô„É≥„ÉàÂá¶ÁêÜÊÄßËÉΩÊ∏¨ÂÆöÂÆüË£Ö
```javascript
class EventPerformanceMonitor {
  constructor() {
    this.eventTimes = {
      mouseEvents: [],
      keyboardEvents: [],
      touchEvents: []
    };
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„ÉàÁõ£Ë¶ñ
    ['click', 'mousemove', 'mouseup', 'mousedown'].forEach(eventType => {
      document.addEventListener(eventType, (e) => {
        this.measureEventHandling(e, 'mouseEvents');
      }, { capture: true });
    });
    
    // „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„ÉàÁõ£Ë¶ñ
    ['keydown', 'keyup'].forEach(eventType => {
      document.addEventListener(eventType, (e) => {
        this.measureEventHandling(e, 'keyboardEvents');
      }, { capture: true });
    });
  }
  
  measureEventHandling(event, category) {
    const startTime = performance.now();
    
    // Ê¨°„ÅÆ„Éï„É¨„Éº„É†„ÅßÂá¶ÁêÜÂÆå‰∫ÜÊôÇÈñì„ÇíÊ∏¨ÂÆö
    requestAnimationFrame(() => {
      const endTime = performance.now();
      const duration = endTime - startTime;
      
      this.eventTimes[category].push({
        type: event.type,
        duration,
        timestamp: Date.now()
      });
      
      // Áõ¥Ëøë100‰ª∂„ÅÆ„Åø‰øùÊåÅ
      if (this.eventTimes[category].length > 100) {
        this.eventTimes[category].shift();
      }
      
      // ÈÅÖÂª∂Ë≠¶ÂëäÔºà100msË∂ÖÈÅéÔºâ
      if (duration > 100) {
        console.warn(`Slow ${event.type} handling:`, duration.toFixed(2), 'ms');
      }
    });
  }
  
  getStats(category) {
    const data = this.eventTimes[category];
    if (data.length === 0) return null;
    
    const durations = data.map(item => item.duration);
    const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
    const max = Math.max(...durations);
    
    return {
      count: data.length,
      avgDuration: avg.toFixed(2),
      maxDuration: max.toFixed(2)
    };
  }
}
```

## Undo/RedoÊÄßËÉΩÊ∏¨ÂÆöÂÆüË£Ö
```javascript
class UndoRedoMonitor {
  constructor() {
    this.metrics = {
      undoTimes: [],
      redoTimes: [],
      historySize: 0,
      operationCount: 0
    };
  }
  
  measureUndoOperation(undoFunction) {
    const startTime = performance.now();
    
    return new Promise((resolve) => {
      const result = undoFunction();
      
      // ÈùûÂêåÊúüÂá¶ÁêÜÂÆå‰∫ÜÂæå„Å´ÊôÇÈñìÊ∏¨ÂÆö
      Promise.resolve(result).then(() => {
        const duration = performance.now() - startTime;
        this.metrics.undoTimes.push(duration);
        this.metrics.operationCount++;
        
        // Áõ¥Ëøë50‰ª∂„ÅÆ„Åø‰øùÊåÅ
        if (this.metrics.undoTimes.length > 50) {
          this.metrics.undoTimes.shift();
        }
        
        // ÈÅÖÂª∂Ë≠¶ÂëäÔºà500msË∂ÖÈÅéÔºâ
        if (duration > 500) {
          console.warn('Slow undo operation:', duration.toFixed(2), 'ms');
        }
        
        this.updateDisplay();
        resolve(result);
      });
    });
  }
  
  measureRedoOperation(redoFunction) {
    const startTime = performance.now();
    
    return new Promise((resolve) => {
      const result = redoFunction();
      
      Promise.resolve(result).then(() => {
        const duration = performance.now() - startTime;
        this.metrics.redoTimes.push(duration);
        this.metrics.operationCount++;
        
        if (this.metrics.redoTimes.length > 50) {
          this.metrics.redoTimes.shift();
        }
        
        if (duration > 500) {
          console.warn('Slow redo operation:', duration.toFixed(2), 'ms');
        }
        
        this.updateDisplay();
        resolve(result);
      });
    });
  }
  
  updateHistorySize(historyData) {
    // Â±•Ê≠¥„Éá„Éº„Çø„ÅÆ„É°„É¢„É™„Çµ„Ç§„Ç∫„ÇíÊé®ÂÆö
    this.metrics.historySize = JSON.stringify(historyData).length;
    this.updateDisplay();
  }
  
  getStats() {
    const undoAvg = this.metrics.undoTimes.length > 0 ? 
      (this.metrics.undoTimes.reduce((a, b) => a + b, 0) / this.metrics.undoTimes.length).toFixed(2) : 0;
    const redoAvg = this.metrics.redoTimes.length > 0 ? 
      (this.metrics.redoTimes.reduce((a, b) => a + b, 0) / this.metrics.redoTimes.length).toFixed(2) : 0;
    
    return {
      undoAverage: undoAvg,
      redoAverage: redoAvg,
      historySize: Math.round(this.metrics.historySize / 1024), // KB
      totalOperations: this.metrics.operationCount
    };
  }
}
```

## Áµ±ÂêàÂÆüË£Ö (Next.js)
```typescript
// hooks/usePerformanceMonitor.ts - Áµ±Âêà„Éï„ÉÉ„ÇØ
import { useState, useEffect, useCallback } from 'react';
import { useFPSMonitor } from './useFPSMonitor';
import { useMemoryMonitor } from './useMemoryMonitor';
import { useTimingMonitor } from './useTimingMonitor';

interface PerformanceConfig {
  enabled: boolean;
  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  updateInterval?: number;
}

interface PerformanceMetrics {
  fps: { fps: number; status: 'good' | 'warning' | 'error' };
  memory: { used: number; total: number; limit: number; trend?: string };
  timing: Record<string, { avg: number; max: number; p95: number; count: number }>;
}

export const usePerformanceMonitor = (config: PerformanceConfig) => {
  const [metrics, setMetrics] = useState<PerformanceMetrics>({
    fps: { fps: 0, status: 'good' },
    memory: { used: 0, total: 0, limit: 0 },
    timing: {}
  });

  const fps = useFPSMonitor(config.enabled);
  const memory = useMemoryMonitor(config.enabled, config.updateInterval);
  const timing = useTimingMonitor(config.enabled);

  // FPSÊõ¥Êñ∞„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ
  fps.registerDisplayCallback(useCallback((fpsData) => {
    setMetrics(prev => ({ ...prev, fps: fpsData }));
  }, []));

  // „É°„É¢„É™Êõ¥Êñ∞„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ
  memory.registerCallback(useCallback((memoryData) => {
    setMetrics(prev => ({ 
      ...prev, 
      memory: { 
        used: memoryData.used, 
        total: memoryData.total, 
        limit: memoryData.limit,
        trend: memoryData.trend 
      }
    }));
  }, []));

  // „Çø„Ç§„Éü„É≥„Ç∞Êõ¥Êñ∞„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ
  timing.registerCallback(useCallback((category, stats) => {
    setMetrics(prev => ({
      ...prev,
      timing: { ...prev.timing, [category]: stats }
    }));
  }, []));

  const exportData = useCallback((format: 'json' | 'csv' = 'json') => {
    const data = {
      timestamp: new Date().toISOString(),
      fps: metrics.fps,
      memory: memory.getHistory(),
      timing: timing.getAllStats()
    };

    if (format === 'json') {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `performance-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }
  }, [metrics, memory, timing]);

  const measureOperation = useCallback(async <T>(
    operation: () => Promise<T> | T,
    category: 'rendering' | 'interaction' | 'taskOperation' | 'undoRedo' = 'interaction'
  ): Promise<T> => {
    const timer = timing.startTimer(category);
    try {
      const result = await operation();
      return result;
    } finally {
      timer.end();
    }
  }, [timing]);

  return {
    metrics,
    exportData,
    measureOperation,
    startTimer: timing.startTimer,
    isEnabled: config.enabled
  };
};

// components/DebugDashboard.tsx - Ë°®Á§∫„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà
import React from 'react';

interface DebugDashboardProps {
  metrics: PerformanceMetrics;
  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';
  onClose?: () => void;
  onExport?: () => void;
}

export const DebugDashboard: React.FC<DebugDashboardProps> = ({
  metrics,
  position = 'top-right',
  onClose,
  onExport
}) => {
  const positionClasses = {
    'top-left': 'top-4 left-4',
    'top-right': 'top-4 right-4',
    'bottom-left': 'bottom-4 left-4',
    'bottom-right': 'bottom-4 right-4'
  };

  return (
    <div className={`fixed ${positionClasses[position]} bg-black/90 text-white p-4 rounded-lg z-50 font-mono text-xs min-w-[200px]`}>
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-sm font-bold">Performance Monitor</h3>
        <button onClick={onClose} className="text-gray-400 hover:text-white">√ó</button>
      </div>
      
      {/* FPS */}
      <div className="flex items-center gap-2 mb-1">
        <div className={`w-2 h-2 rounded-full ${
          metrics.fps.status === 'good' ? 'bg-green-500' :
          metrics.fps.status === 'warning' ? 'bg-yellow-500' : 'bg-red-500'
        }`} />
        <span>FPS: {metrics.fps.fps}</span>
      </div>
      
      {/* Memory */}
      <div className="mb-1">
        <span>Memory: {metrics.memory.used}MB / {metrics.memory.total}MB</span>
        {metrics.memory.trend && (
          <span className={`ml-2 text-xs ${
            metrics.memory.trend === 'increasing' ? 'text-red-400' :
            metrics.memory.trend === 'decreasing' ? 'text-green-400' : 'text-gray-400'
          }`}>
            {metrics.memory.trend}
          </span>
        )}
      </div>
      
      {/* Timing */}
      <div className="mb-2">
        {Object.entries(metrics.timing).map(([category, stats]) => (
          <div key={category} className="text-xs">
            {category}: {stats.avg}ms avg, {stats.max}ms max
          </div>
        ))}
      </div>
      
      <div className="flex gap-2">
        <button 
          onClick={onExport}
          className="text-xs bg-blue-600 hover:bg-blue-700 px-2 py-1 rounded"
        >
          Export
        </button>
      </div>
    </div>
  );
};
```

