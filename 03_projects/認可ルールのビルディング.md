---
type: note
tags:
- '#ai/ref'
---
# 認可ルールのビルディング

## なぜこの設計が必要なのか

### 背景
認可処理では、複数の条件を組み合わせた複雑な判定が必要になる。例：
- 「リソースの所有者 AND （読み取り権限 OR 管理者権限）」
- 「アクティブユーザー AND （部署メンバー OR プロジェクトメンバー）」

従来の実装では、このような複雑な条件をハードコードしていたが、以下の問題があった：
- 条件の変更が困難
- 可読性が低い
- テストが困難
- 再利用性が低い

### 目標
- **可読性**: 論理演算が直感的に理解できる
- **再利用性**: 個別のルールを組み合わせて利用可能
- **保守性**: 条件の変更が容易
- **テスト性**: 個別ルールとその組み合わせをテスト可能

## 設計決定: 静的メソッドによる構築

### 採用した実装
```typescript
class AuthorizationRuleGroup implements IAuthorizationRule {
    constructor(
        private type: 'AND' | 'OR',
        private rules: IAuthorizationRule[]
    ) {}

    static and(...rules: IAuthorizationRule[]): IAuthorizationRule {
        return new AuthorizationRuleGroup('AND', rules);
    }

    static or(...rules: IAuthorizationRule[]): IAuthorizationRule {
        return new AuthorizationRuleGroup('OR', rules);
    }

    async ok(): Promise<boolean> {
        if (this.type === 'AND') {
            for (const rule of this.rules) {
                if (!await rule.ok()) {
                    return false;  // 短絡評価
                }
            }
            return true;
        } else {
            for (const rule of this.rules) {
                if (await rule.ok()) {
                    return true;  // 短絡評価
                }
            }
            return false;
        }
    }
}

// 使用例
const authRule = AuthorizationRuleGroup.and(
    new IsOwnerRule(userId, resource),
    AuthorizationRuleGroup.or(
        new HasPermissionRule(userId, 'read'),
        new HasPermissionRule(userId, 'admin')
    )
);
```

### なぜ静的メソッドを選んだか

1. **直感的**: `and()` と `or()` は論理演算そのもの
2. **シンプル**: 余計な複雑さがない
3. **読みやすい**: ネストが明確に表現される
4. **型安全**: TypeScriptの恩恵を完全に受ける
5. **インポート不要**: クラス自体に機能が含まれている

## 検討した代替案

### 1. Builderパターン
```typescript
class AuthorizationRuleBuilder {
    static and(...rules: IAuthorizationRule[]): AuthorizationRuleBuilder {
        return new AuthorizationRuleBuilder(new AuthorizationRuleGroup('AND', rules));
    }

    and(rule: IAuthorizationRule): AuthorizationRuleBuilder {
        return new AuthorizationRuleBuilder(
            new AuthorizationRuleGroup('AND', [this.rule, rule])
        );
    }

    build(): IAuthorizationRule {
        return this.rule;
    }
}

// 使用例
const rule = AuthorizationRuleBuilder
    .and(new IsOwnerRule(), new HasPermissionRule())
    .build();
```

**却下理由**:
- `build()` メソッドが余計で分かりづらい
- チェーンメソッドが複雑すぎる
- 本質的な価値を提供しない

### 2. ファクトリー関数
```typescript
export const and = (...rules: IAuthorizationRule[]): IAuthorizationRule => 
    new AuthorizationRuleGroup('AND', rules);

export const or = (...rules: IAuthorizationRule[]): IAuthorizationRule => 
    new AuthorizationRuleGroup('OR', rules);

// 使用例
const authRule = and(
    new IsOwnerRule(userId, resource),
    or(new HasPermissionRule(userId, 'read'), new HasPermissionRule(userId, 'admin'))
);
```

**却下理由**:
- 別ファイルからのインポートが必要
- クラスの機能が分散する
- 静的メソッドと比べて明確な利点がない

### 3. 演算子オーバーロード風
```typescript
class BaseAuthorizationRule implements IAuthorizationRule {
    and(rule: IAuthorizationRule): IAuthorizationRule {
        return new AuthorizationRuleGroup('AND', [this, rule]);
    }

    or(rule: IAuthorizationRule): IAuthorizationRule {
        return new AuthorizationRuleGroup('OR', [this, rule]);
    }
}

// 使用例
const authRule = new IsOwnerRule(userId, resource)
    .and(new HasPermissionRule(userId, 'read').or(new HasPermissionRule(userId, 'admin')));
```

**却下理由**:
- 全てのルールクラスで同じメソッドを実装する必要がある
- 複雑なネストが読みづらい
- 基底クラスが必要になる

## パフォーマンス設計決定: 短絡評価

### 採用した実装
```typescript
// 短絡評価による実装
async ok(): Promise<boolean> {
    if (this.type === 'AND') {
        for (const rule of this.rules) {
            if (!await rule.ok()) {
                return false;  // 一つでもfalseなら即座に終了
            }
        }
        return true;
    } else {
        for (const rule of this.rules) {
            if (await rule.ok()) {
                return true;  // 一つでもtrueなら即座に終了
            }
        }
        return false;
    }
}
```

### 却下した代替案: 並列実行
```typescript
// 並列実行による実装（却下）
async ok(): Promise<boolean> {
    const results = await Promise.all(
        this.rules.map(rule => rule.ok())
    );

    return this.type === 'AND'
        ? results.every(r => r)
        : results.some(r => r);
}
```

### なぜ短絡評価を選んだか

1. **現状のパフォーマンス要件**: 認可処理の並列化による恩恵が限定的
2. **リソース効率**: 不要な処理を早期に打ち切れる
3. **外部依存の軽減**: データベースアクセスなどの重い処理を削減
4. **論理演算の自然な動作**: AND/ORの一般的な動作に合致

**並列実行を却下した理由**:
- 認可処理は通常軽量で、並列化の恩恵が少ない
- すべてのルールを実行することで、不要なリソース消費が発生
- 短絡評価の方が論理的に自然

## 結論

**静的メソッド + 短絡評価**の組み合わせにより、以下を実現：

- **直感的な可読性**: 論理演算が自然に表現される
- **シンプルな実装**: 余計な複雑さを排除
- **効率的な実行**: 不要な処理を早期に打ち切り
- **保守性**: 条件の変更が容易
- **テスト性**: 個別ルールとその組み合わせをテスト可能

この設計により、複雑な認可条件を直感的かつ効率的に表現できる基盤が確立された。