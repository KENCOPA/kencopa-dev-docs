---
type: note
moc: "[[🏷️基本設計書]]"
tags:
- '#ai/ref'
---
# Overview

本ドキュメントは、Kunai Frontendにおけるテナント管理システムの設計について説明する。テナント管理は、マルチテナントSaaSアプリケーションにおいて、ユーザーが複数のテナント（組織）に所属し、切り替えながら作業できる仕組みを提供する。

# Why - なぜこの設計が必要か

## 背景
- ユーザーは複数のテナント（組織）に所属する可能性がある
- 各APIリクエストは適切なテナントコンテキストで実行される必要がある
- テナント切り替えはシームレスで、状態が保持される必要がある
- リンク対応: 特定のテナント内のページのURLが開ける必要がある

## 解決すべき課題
1. **テナントコンテキストの管理**: 現在選択されているテナントを追跡
2. **APIリクエストの自動補完**: 各APIリクエストに自動的にテナントIDを付与
3. **関心の分離**: ビューコンポーネントからビジネスロジックを分離

# Frontend Architecture

#### URL構造

```
/tenant-selection          # テナント選択画面
/home/[tenantId]           # テナント固有のホーム画面
/home/[tenantId]/projects  # テナント固有のプロジェクト一覧
/home/[tenantId]/sites     # テナント固有のサイト一覧
/home/[tenantId]/...       # その他のテナント固有ページ
```

# データフロー

```
┌─────────────────┐
│   URL Path      │
│ /home/[tenantId]│
└────────┬────────┘
         ↓
┌─────────────────┐
│   useParams()   │
│ Extract tenantId│
└────────┬────────┘
         ↓
┌─────────────────┐
│   useEffect()   │
│ Sync to Cookie  │
└────────┬────────┘
         ↓
┌─────────────────┐
│     Cookie      │
│ tenantId=xxx    │
└────────┬────────┘
         ↓
┌─────────────────┐
│   Middleware    │
│ Read Cookie     │
└────────┬────────┘
         ↓
┌─────────────────┐
│  API Request    │
│ X-Tenant-ID: xxx│
└─────────────────┘
```

## 主要コンポーネント

#### 1. Dynamic Routes (Next.js)
URLパスからテナントIDを抽出する仕組み。

```typescript
// app/(tenantContext)/home/[tenantId]/page.tsx
const { tenantId } = useParams<{ tenantId: string }>();
```

#### 2. Cookie同期メカニズム
URLパラメータをCookieに同期し、永続化とAPI通信での利用を可能にする。

```typescript
useEffect(() => {
  if (tenantId) {
    setCookie("tenantId", tenantId, { path: "/", maxAge: 60 * 60 * 24 * 7 });
  }
}, [tenantId]);
```

#### 3. tenantContextRequestMiddleware
API通信時に自動的にテナントIDをヘッダーに付与する。
see [[🗒️ マルチテナントシステム設計#4. テナント切り替え・認証認可]]

```typescript
export const tenantContextRequestMiddleware: Middleware = {
  onRequest: ({ request }) => {
    const url = new URL(request.url);
    
    if (url.pathname.startsWith("/api/v1/tenants")) {
      const tenantId = getCookie("tenantId");
      
      if (tenantId) {
        request.headers.set("X-Tenant-ID", tenantId);
      }
    }
    
    return request;
  },
};
```

## Design Decisions

### 1. URLパスベースのテナント管理

**決定**: `/home/[tenantId]/...` 形式でテナントIDをURLパスに含める

**理由**:
- **共有可能性**: URLを共有するだけで同じテナントコンテキストにアクセス可能
- **RESTful設計**: リソースの階層が明確で直感的
- **ブックマーク対応**: ブラウザの標準機能が自然に動作
- **SEO対応**: 検索エンジンがテナント別のページを正しく認識可能
- **ブラウザ履歴**: 戻る/進むボタンが期待通りに動作

**代替案と却下理由**:
- **Query Parameter方式** (`?tenantId=xxx`)
  - URLが冗長になり、RESTfulでない
  - パラメータが意図せず削除されやすい
- **Subdomain方式** (`{tenantId}.app.com`)
  - DNS設定が複雑、開発環境での実装が困難
  - CORS設定が複雑になる
- **Header-Only方式**
  - URLからテナントが識別できない
  - 共有・ブックマーク不可

### 2. Cookie による状態管理

**決定**: URLパラメータからCookieに同期して状態を保持

**理由**:
- **Middleware統合**: HTTPリクエストで自動的にCookieが送信される
- **永続性**: ページリロード時も状態を維持
- **SSR対応**: サーバーサイドレンダリング時にも利用可能
- **セキュリティ**: 適切な設定でセキュアに管理可能

**代替案と却下理由**:
- **LocalStorage**
  - SSRで使用不可
  - HTTPリクエストに自動的に含まれない
- **SessionStorage**
  - タブ間で共有されない
  - ブラウザを閉じると消える
- **メモリのみ**
  - ページリロードで状態が失われる

### 3. Middleware による自動ヘッダー付与

**決定**: openapi-fetchのmiddlewareでX-Tenant-IDヘッダーを自動付与

**理由**:
- **開発者体験**: 各API呼び出しで明示的な指定が不要
- **一貫性**: すべてのAPIリクエストで統一的に処理
- **保守性**: ヘッダー名や処理の変更が一箇所で可能
- **エラー防止**: 付与漏れを防げる

**代替案と却下理由**:
- **手動付与**
  - 開発者の負担が大きい
  - 付与漏れのリスク
- **APIパス埋め込み** (`/api/v1/{tenantId}/...`)
  - API設計が複雑になる
  - 冗長

## Implementation Guide

### 1. ルーティング設定

```typescript
// app/(tenantContext)/home/[tenantId]/page.tsx
"use client"
import { setCookie } from "@/shared/lib/cookie";
import { useParams } from "next/navigation";
import { useEffect } from "react";

export default function Page() {
  const { tenantId } = useParams<{ tenantId: string }>();
  
  useEffect(() => {
    if (tenantId) {
      setCookie("tenantId", tenantId, { path: "/", maxAge: 60 * 60 * 24 * 7 });
    }
  }, [tenantId]);

  return <HomePage />;
}
```

### 2. テナント選択

```typescript
// components/tenant-selection/index.tsx
const handleTenantClick = async (tenantId: string) => {
  router.push(`/home/${tenantId}`);
};
```

### 3. テナント内でのナビゲーション

```typescript
// 同一テナント内でのページ遷移
const { tenantId } = useParams<{ tenantId: string }>();
router.push(`/home/${tenantId}/projects`);
```

### 4. API通信設定

```typescript
// services/shared/clients/httpClient/httpClient.ts
const client = createClient<paths>({
  baseUrl: process.env.NEXT_PUBLIC_API_BASE_URL,
});

// middlewareを適用
client.use(tenantContextRequestMiddleware);
```

## Security Considerations

### 1. アクセス権限の検証
- **サーバーサイド検証必須**: クライアントから送信されるtenantIdは信頼できない
- **ユーザーの所属確認**: APIレベルで認証ユーザーがテナントに所属しているか確認
- **404処理**: 権限のないテナントアクセス時は404を返す

### 2. Cookie セキュリティ
- **現在の設定**:
  - Path: "/" (全パスで有効)
  - MaxAge: 7日間
  - HttpOnly: 未設定（クライアントサイドアクセスが必要）
- **推奨事項**:
  - Secure: HTTPS環境では有効化
  - SameSite: "Lax" または "Strict" でCSRF対策

### 3. 入力検証
- **tenantId形式チェック**: UUID形式などの検証
- **SQLインジェクション対策**: パラメータのサニタイズ
- **パストラバーサル対策**: "../" などの危険な文字列を拒否

## Benefits

### 1. ユーザビリティ
- **直感的なURL**: `/home/abc-123/projects` は明確で理解しやすい
- **簡単な共有**: URLをコピー&ペーストするだけ
- **ブラウザ機能**: 戻る/進む、ブックマーク、履歴が自然に動作

### 2. 開発体験
- **シンプルな実装**: Next.jsの標準機能のみ使用
- **明確なデバッグ**: URLを見ればテナント状態が分かる
- **テスト容易性**: URLパラメータでテストケースを制御

### 3. システム特性
- **スケーラビリティ**: 状態管理がシンプルで軽量
- **キャッシュ効率**: URLベースでCDNキャッシュが可能
- **SEO**: テナント別のコンテンツが適切にインデックスされる

## Known Limitations

1. **URLの長さ**: 深い階層でURLが長くなる可能性
2. **移行コスト**: 既存のURLスキームからの移行が必要
3. **クライアント状態**: URLに含まれない状態は別途管理が必要

## Future Enhancements

1. **テナント情報のプリフェッチ**
   - ページ遷移前にテナント情報を事前取得
   - React Queryでのキャッシュ管理

2. **カスタムドメイン対応**
   - 企業ごとの独自ドメイン設定
   - DNS設定の自動化

3. **テナント切り替えUI**
   - グローバルナビゲーションでの切り替え
   - 最近使用したテナントのクイックアクセス

4. **アナリティクス統合**
   - テナント別の利用状況追跡
   - パフォーマンスモニタリング

# Backend Architecture

## 概要

バックエンドでは、フロントエンドから送信される `X-Tenant-ID` ヘッダーを処理し、適切なテナントコンテキストでAPIリクエストを実行する。

## ルーティング構造

```
/api/v1/
├── public/              # 認証不要
├── protected/           # 認証必要（テナント不要）
│   └── userContext/          # ユーザー固有のリソース
└── protected/tenantContext/   # 認証＋テナント必要
    └── {resources}/    # テナント固有のリソース
```

## Middleware アーキテクチャ

see [[🗒️ マルチテナントシステム設計#4. テナント切り替え・認証認可]]
```
┌─────────────────────────────────────────────────┐
│              Request Flow                        │
│                                                 │
│  Client Request                                 │
│       ↓                                        │
│  authMiddleware (全protected配下)               │
│       ↓                                        │
│  tenantContextMiddleware (tenants配下のみ)      │
│       ↓                                        │
│  Route Handler                                  │
└─────────────────────────────────────────────────┘
```

## Backend Design Decisions

### 1. Middleware による段階的な認証・認可

**決定**: authMiddleware → tenantContextMiddleware の順序で適用

**理由**:
- 認証されていないユーザーのテナントアクセスを防ぐ
- エラーメッセージの適切な順序（認証エラー → テナントエラー）
- 関心の分離（認証と認可の責務を分離）

**代替案**:
- 単一のミドルウェアで両方を処理
  - 却下理由: 責務が混在し、テストが複雑になる
- テナントチェックを各ハンドラーで実施
  - 却下理由: DRY原則違反、実装漏れのリスク

### 2. ミドルウェア層でのmembership認可

**決定**: tenantContextMiddleware でuserIdとtenantIdのmembership存在チェックを実行

**理由**:
- `/api/v1/tenants/`パスアクセス時点で、membershipが必須条件である
- 認可が失敗したリクエストをアプリケーションロジック内に入れない
- usecase内のauthorizerで行う共通的な認可処理を省略できる
- パフォーマンス向上（不要な処理の削減）

**代替案**:
- usecase内(authorizer)での認可処理
  - 却下理由: 認可が失敗するリクエストがアプリケーションロジック内に侵入する
  - 却下理由: 各authorizerでの重複実装が発生する

### 3. 型安全なテナントコンテキスト

**決定**: `TenantApplicationEntry` 型でテナントIDを必須化

**理由**:
- コンパイル時にテナントIDの存在を保証
- 開発者が誤ってテナントIDなしでアクセスすることを防ぐ
- IDEの補完機能が適切に動作

**実装**:
```typescript
// 通常のルート
type CommonVariables = {
  requestId: string;
  authJWTPayload: AuthJWTPayload;
};

// テナントコンテキストのルート
type TenantContextVariables = CommonVariables & {
  tenantContextPayload: TenantContextPayload; // 必須
};
```

**代替案**:
- ランタイムチェックのみ
  - 却下理由: 実行時エラーのリスク、開発体験の低下
- すべてのルートでオプショナル
  - 却下理由: 型の恩恵を受けられない

### 4. HTTPヘッダーによるテナント識別

**決定**: `X-Tenant-ID` カスタムヘッダーを使用

**理由**:
- RESTfulな設計（リソースのコンテキストを明確化）
- プロキシやロードバランサーでの処理が容易
- 標準的なHTTPヘッダーとの衝突を避ける

**代替案**:
- URLパスパラメータ (`/api/v1/tenants/{tenantId}/resources`)
  - 却下理由: URLが冗長、リソース指向でない
- クエリパラメータ
  - 却下理由: キャッシュの問題、URLの可読性低下
- JWTトークンに含める
  - 却下理由: テナント切り替え時にトークン再発行が必要
  - also see [[🗒️ マルチテナントシステム設計#セッショントークン方式]]

### 5. エラーハンドリング戦略

**決定**: 403 Forbidden for missing tenant header

**理由**:
- 認証は成功しているが、リソースへのアクセス権限がないことを明確に示す
- 400 Bad Requestよりも意味的に正確


```

### 今後の拡張ポイント

1. **パフォーマンス最適化**
   - membership情報のキャッシュ
   - 権限チェックの最適化

2. **監査ログ**
   - テナントコンテキストでの操作履歴
   - クロステナントアクセスの検知



